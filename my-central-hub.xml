This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, **/*.json, **/.gitignore, node_modules/**, thumbnails/**, **/dist/**, **/build/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
config/
  server.config.ts
core/
  http_stress.test.ts
  httpParser.test.ts
  httpParser.ts
  parser.test.ts
  parser.ts
  router.test.ts
  router.ts
  server.ts
entities/
  http.ts
  sendResponse.ts
modules/
  file-streamer/
    fileService.test.ts
    fileService.ts
    fileStreamingController.test.ts
    fileStreamingController.ts
    index.ts
routes/
  files.routes.ts
  index.ts
  stream.routes.ts
utils/
  helpers.test.ts
  helpers.ts
  httpHelpers.ts
  logger.test.ts
  logger.ts
  mimeTypes.ts
main.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="config/server.config.ts">
import dotenv from 'dotenv';
import { join } from 'path';
import { logger } from '../utils/logger';
// Load environment variables from .env file
dotenv.config();
export const config = {
  port: process.env.PORT ? parseInt(process.env.PORT, 10) : 8080,
  publicDir: process.env.PUBLIC_DIR
    ? join(process.cwd(), process.env.PUBLIC_DIR)
    : join(process.cwd(), 'public'),
  mediaDir: process.env.MEDIA_DIR
    ? join(process.cwd(), process.env.MEDIA_DIR)
    : join(process.cwd(), 'media'),
  headerTimeoutMs: process.env.HEADER_TIMEOUT_MS
    ? Math.max(parseInt(process.env.HEADER_TIMEOUT_MS, 10), 0)
    : 5000,
  bodyTimeoutMs: process.env.BODY_TIMEOUT_MS
    ? Math.max(parseInt(process.env.BODY_TIMEOUT_MS, 10), 0)
    : 10000,
};
logger.info(`Server configuration:`);
logger.info(`- Port: ${config.port}`);
logger.info(`- Public Directory: ${config.publicDir}`);
logger.info(`- Media Directory: ${config.mediaDir}`);
logger.info(`- Header Timeout: ${config.headerTimeoutMs}ms`);
logger.info(`- Body Timeout: ${config.bodyTimeoutMs}ms`);
</file>

<file path="core/httpParser.ts">
import { IncomingRequest } from '../entities/http';
import { URL } from 'url';
import { logger } from '../utils/logger';
enum ParserState {
  REQUEST_LINE,
  HEADERS,
  BODY,
  CHUNK_SIZE,
  CHUNK_BODY,
  CHUNK_TRAILER,
  DONE,
  ERROR,
}
const ALLOWED_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'];
const MAX_HEADER_BYTES = 8192; // 8KB
const MAX_HEADERS = 100; // Maximum number of headers allowed
const MAX_BODY_BYTES = 10 * 1024 * 1024; // 10 MB
const CRLF = Buffer.from('\r\n');
export class HttpRequestParser {
  protected buffer = Buffer.alloc(0);
  private state = ParserState.REQUEST_LINE;
  private headers: Record<string, string> = {};
  private headersMap = new Map<string, string[]>();
  private bodyChunks: Buffer[] = [];
  private method = '';
  private httpVersion = '';
  private url!: URL;
  private contentLength = 0;
  private remainingBody = 0;
  private isChunked = false;
  private invalid = false;
  private lastHeaderKey: string | null = null;
  /**
   * Returns the number of pending bytes in the parser buffer.
   */
  public getPendingBytes(): number {
    return this.buffer.length;
  }
  feed(data: Buffer): IncomingRequest | null {
    this.buffer = Buffer.concat([this.buffer, data]);
    try {
      while (true) {
        // REQUEST_LINE
        if (this.state === ParserState.REQUEST_LINE) {
          const idx = this.buffer.indexOf('\r\n');
          if (idx === -1) return null;
          const requestLine = this.buffer.subarray(0, idx).toString('utf8');
          this.buffer = this.buffer.subarray(idx + 2);
          const parts = requestLine.split(' ');
          if (parts.length !== 3) {
            this._setError('Invalid request line: ' + requestLine);
            return this._errorResponse();
          }
          const [method, reqPath, version] = parts;
          if (!ALLOWED_METHODS.includes(method)) {
            this._setError('Unsupported method: ' + method);
            continue;
          }
          if (!version.startsWith('HTTP/')) {
            this._setError('Invalid HTTP version: ' + version);
            continue;
          }
          this.method = method;
          this.httpVersion = version;
          try {
            this.url = new URL(reqPath, 'http://placeholder');
          } catch {
            this._setError('Malformed URL: ' + reqPath);
            continue;
          }
          this.state = ParserState.HEADERS;
        }
        // HEADERS
        if (this.state === ParserState.HEADERS) {
          // find end-of-headers or handle empty header block
          const idx = this.buffer.indexOf('\r\n\r\n');
          let headersRaw = '';
          if (idx === -1) {
            // immediate blank line → zero headers
            if (this.buffer.subarray(0, 2).equals(CRLF)) {
              this.buffer = this.buffer.subarray(2);
            } else {
              if (this.buffer.length > MAX_HEADER_BYTES) {
                this._setError('Headers too large');
                return this._errorResponse();
              }
              return null;
            }
          } else {
            headersRaw = this.buffer.subarray(0, idx).toString('utf8');
            this.buffer = this.buffer.subarray(idx + 4);
          }
          const lines = headersRaw.split('\r\n');
          let headerCount = 0;
          for (const line of lines) {
            if (line.trim() === '') continue;
            // support folded headers per RFC7230 §3.2.4
            if (line.startsWith(' ') || line.startsWith('\t')) {
              if (this.lastHeaderKey) {
                const prev = this.headers[this.lastHeaderKey];
                this.headers[this.lastHeaderKey] = prev + ' ' + line.trim();
                // update map too
                this.headersMap.set(
                  this.lastHeaderKey,
                  (this.headersMap.get(this.lastHeaderKey) || []).concat(
                    this.headers[this.lastHeaderKey],
                  ),
                );
                continue;
              } else {
                this._setError('Invalid header folding');
                return this._errorResponse();
              }
            }
            const colon = line.indexOf(':');
            if (colon === -1) {
              this._setError('Invalid header line: ' + line);
              continue;
            }
            const key = line.slice(0, colon).trim().toLowerCase();
            const value = line.slice(colon + 1).trim();
            this.headers[key] = value;
            this.headersMap.set(key, [...(this.headersMap.get(key) ?? []), value]);
            this.lastHeaderKey = key;
            headerCount++;
            if (headerCount > MAX_HEADERS) {
              this._setError('Too many headers');
              return this._errorResponse();
            }
          }
          // Short-circuit on parse errors
          if (this.invalid) {
            return this._errorResponse();
          }
          // enforce Host header for HTTP/1.1
          if (this.httpVersion === 'HTTP/1.1' && !this.headers['host']) {
            this._setError('Missing Host header');
            return this._errorResponse();
          }
          if (
            this.headers['transfer-encoding'] &&
            this.headers['transfer-encoding'].toLowerCase() === 'chunked'
          ) {
            this.isChunked = true;
            this.state = ParserState.CHUNK_SIZE;
          } else if (this.headers['content-length']) {
            this.contentLength = parseInt(this.headers['content-length'], 10);
            if (isNaN(this.contentLength) || this.contentLength < 0) {
              this._setError('Invalid Content-Length');
              continue;
            }
            this.remainingBody = this.contentLength;
            this.state = this.contentLength > 0 ? ParserState.BODY : ParserState.DONE;
          } else {
            this.state = ParserState.DONE;
          }
        }
        // BODY
        if (this.state === ParserState.BODY) {
          this.contentLength = parseInt(this.headers['content-length'], 10);
          if (isNaN(this.contentLength) || this.contentLength < 0) {
            this._setError('Invalid Content-Length');
            continue;
          }
          if (this.contentLength > MAX_BODY_BYTES) {
            this._setError('Request body too large');
            continue;
          }
          this.remainingBody = this.contentLength;
          if (this.buffer.length < this.remainingBody) return null;
          this.bodyChunks.push(this.buffer.subarray(0, this.remainingBody));
          this.buffer = this.buffer.subarray(this.remainingBody);
          this.remainingBody = 0;
          this.state = ParserState.DONE;
        }
        // CHUNK_SIZE
        if (this.state === ParserState.CHUNK_SIZE) {
          const idx = this.buffer.indexOf('\r\n');
          if (idx === -1) return null;
          const line = this.buffer.subarray(0, idx).toString('utf8');
          this.buffer = this.buffer.subarray(idx + 2);
          const chunkSize = parseInt(line, 16);
          if (isNaN(chunkSize)) {
            this._setError('Invalid chunk size: ' + line);
            continue;
          }
          if (chunkSize === 0) {
            this.state = ParserState.CHUNK_TRAILER;
          } else {
            this.remainingBody = chunkSize;
            this.state = ParserState.CHUNK_BODY;
          }
        }
        // CHUNK_BODY
        if (this.state === ParserState.CHUNK_BODY) {
          if (this.remainingBody > MAX_BODY_BYTES) {
            this._setError('Chunk body too large');
            continue;
          }
          if (this.buffer.length < this.remainingBody) return null;
          const chunk = this.buffer.subarray(0, this.remainingBody);
          this.bodyChunks.push(chunk);
          this.buffer = this.buffer.subarray(this.remainingBody);
          this.remainingBody = 0;
          if (this.buffer.length < 2 || !this.buffer.subarray(0, 2).equals(CRLF)) {
            this._setError('Missing CRLF after chunk');
            continue;
          }
          this.buffer = this.buffer.subarray(2);
          this.state = ParserState.CHUNK_SIZE;
        }
        // CHUNK_TRAILER
        if (this.state === ParserState.CHUNK_TRAILER) {
          if (this.buffer.length === 0 || this.buffer.equals(CRLF)) {
            this.buffer = Buffer.alloc(0);
            this.state = ParserState.DONE;
            continue;
          }
          const idx = this.buffer.indexOf('\r\n\r\n');
          if (idx === -1) return null;
          this.buffer = this.buffer.subarray(idx + 4);
          this.state = ParserState.DONE;
        }
        // DONE
        if (this.state === ParserState.DONE) {
          // capture leftover before reset (for pipelining)
          const leftover = this.buffer;
          const finalBody = this.bodyChunks.length ? Buffer.concat(this.bodyChunks) : undefined;
          const request = {
            method: this.method,
            path: this.url.pathname,
            query: Object.fromEntries(this.url.searchParams.entries()),
            headers: this.headers,
            headersMap: this.headersMap,
            httpVersion: this.httpVersion,
            url: this.url,
            body: finalBody,
            raw: '',
            ctx: {},
            invalid: this.invalid,
          };
          this.reset();
          this.buffer = leftover; // restore leftover for next request
          return request;
        }
        // ERROR
        if (this.state === ParserState.ERROR) {
          const errReq = this._errorResponse();
          this.reset();
          return errReq;
        }
      }
    } catch (err) {
      this._setError(`Error during parsing: ${(err as Error).message}`);
      const errReq = this._errorResponse();
      this.reset();
      return errReq;
    }
  }
  private _setError(message: string): void {
    logger.error(message);
    this.invalid = true;
    this.state = ParserState.ERROR;
  }
  /** Build a minimal invalid IncomingRequest */
  private _errorResponse(): IncomingRequest {
    return {
      method: '',
      path: '',
      query: {},
      headers: {},
      headersMap: new Map(),
      httpVersion: '',
      url: new URL('http://invalid'),
      body: undefined,
      raw: '',
      ctx: {},
      invalid: true,
    };
  }
  reset(): void {
    this.buffer = Buffer.alloc(0);
    this.state = ParserState.REQUEST_LINE;
    this.headers = {};
    this.headersMap = new Map();
    this.bodyChunks = [];
    this.method = '';
    this.httpVersion = '';
    this.url = new URL('http://placeholder');
    this.contentLength = 0;
    this.remainingBody = 0;
    this.isChunked = false;
    this.invalid = false;
    this.lastHeaderKey = null;
  }
}
</file>

<file path="core/parser.ts">
import { IncomingRequest } from '../entities/http';
import { URL } from 'url';
const ALLOWED_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'] as const;
const MAX_HEADERS = 1000;
// helper for duplicate headers
function addHeader(map: Map<string, string[]>, key: string, value: string) {
  const k = key.toLowerCase();
  const list = map.get(k) ?? [];
  list.push(value);
  map.set(k, list);
}
export const parser = {
  parse(raw: string): IncomingRequest {
    const dummyUrl = new URL('http://placeholder/');
    const earlyReturn = (): IncomingRequest => ({
      url: dummyUrl,
      path: '',
      query: {},
      httpVersion: '',
      method: '',
      headers: {},
      headersMap: new Map(),
      raw,
      ctx: {},
      invalid: true,
    });
    /* -------- empty buffer guard -------- */
    if (raw.length === 0) return earlyReturn();
    const [head = '', bodyString = ''] = raw.split('\r\n\r\n');
    const lines = head.split('\r\n');
    /* -------- request-line split -------- */
    const [requestLine, ...headerLines] = lines;
    const parts = requestLine.split(' ');
    if (parts.length < 3) return earlyReturn();
    const [method, fullPath, httpVersion] = parts;
    const isOptionsStar = method === 'OPTIONS' && fullPath === '*';
    let invalid =
      !ALLOWED_METHODS.includes(method as (typeof ALLOWED_METHODS)[number]) ||
      (!fullPath.startsWith('/') && !isOptionsStar) ||
      !httpVersion.startsWith('HTTP/');
    /* -------- URL + query -------- */
    const url = isOptionsStar
      ? new URL('http://placeholder')
      : new URL(fullPath, 'http://placeholder');
    const query: Record<string, string> = {};
    url.searchParams.forEach((v, k) => (query[k] = v));
    /* -------- headers -------- */
    const headers: Record<string, string> = {};
    const headersMap = new Map<string, string[]>();
    if (headerLines.length > MAX_HEADERS) invalid = true;
    for (const line of headerLines) {
      const idx = line.indexOf(':');
      if (idx === -1) {
        invalid = true;
        continue;
      }
      const key = line.slice(0, idx).trim();
      const value = line.slice(idx + 1).trim();
      headers[key.toLowerCase()] = value;
      addHeader(headersMap, key, value);
    }
    const body = bodyString ? Buffer.from(bodyString, 'utf-8') : undefined;
    return {
      url,
      path: isOptionsStar ? '*' : decodeURIComponent(url.pathname),
      query,
      httpVersion,
      method,
      headers,
      headersMap,
      body,
      raw,
      ctx: {},
      invalid,
    };
  },
};
</file>

<file path="core/router.ts">
// src/core/router.ts
import { Socket } from 'net';
import { IncomingRequest } from '../entities/http';
import { sendResponse } from '../entities/sendResponse';
import { logger } from '../utils/logger';
/* ───── Types ─────────────────────────────────────────────────────────── */
export type Handler = (req: IncomingRequest, sock: Socket) => Promise<void> | void;
export type Middleware = (
  req: IncomingRequest,
  sock: Socket,
  next: () => Promise<void>,
) => Promise<void> | void;
interface Route {
  method: string; // 'GET' | 'POST' | 'ANY'
  regex: RegExp; // compiled path matcher
  keys: string[]; // param names (for :id stuff)
  handler: Handler;
}
/* ───── Router implementation ─────────────────────────────────────────── */
class Router {
  private middlewares: Middleware[] = [];
  private routes: Route[] = [];
  /* ---------- Middleware ---------- */
  use(mw: Middleware) {
    this.middlewares.push(mw);
  }
  /* ---------- Route registration helpers ---------- */
  add(method: string, path: string, handler: Handler) {
    const { regex, keys } = compilePath(path);
    this.routes.push({ method: method.toUpperCase(), regex, keys, handler });
  }
  get(path: string, h: Handler) {
    this.add('GET', path, h);
  }
  post(path: string, h: Handler) {
    this.add('POST', path, h);
  }
  put(path: string, h: Handler) {
    this.add('PUT', path, h);
  }
  del(path: string, h: Handler) {
    this.add('DELETE', path, h);
  }
  any(path: string, h: Handler) {
    this.add('ANY', path, h);
  }
  /* ---------- Main entry ---------- */
  async handle(req: IncomingRequest, sock: Socket): Promise<void> {
    if (!req.path || typeof req.path !== 'string') {
      sendResponse(sock, 400, { 'Content-Type': 'text/plain' }, 'Bad Request');
      return;
    }
    logger.info(`router saw ${req.method} ${req.path}`);
    // 1. run middleware chain
    let i = 0;
    const run = async (): Promise<void> => {
      if (i < this.middlewares.length) {
        const mw = this.middlewares[i++];
        await mw(req, sock, run);
      }
    };
    await run();
    // 2. route lookup
    const matching = this.routes.filter((r) => r.regex.test(req.path));
    const route =
      matching.find((r) => r.method === req.method) ?? matching.find((r) => r.method === 'ANY');
    if (!route) {
      // Distinguish 404 vs 405
      if (matching.length) {
        sendResponse(
          sock,
          405,
          { Allow: matching.map((r) => r.method).join(', ') },
          'Method Not Allowed',
        );
      } else {
        sendResponse(sock, 404, { 'Content-Type': 'text/plain' }, 'Not Found');
      }
      return;
    }
    // 3. pull params (/:id etc.) → req.ctx.params
    const match = route.regex.exec(req.path)!;
    const params: Record<string, string> = {};
    route.keys.forEach((k, idx) => {
      params[k] = decodeURIComponent(match[idx + 1]);
    });
    (req.ctx ??= {}).params = params;
    // 4. invoke handler
    try {
      await route.handler(req, sock);
    } catch (err) {
      logger.error(`Handler error: ${(err as Error).message}`);
      sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, '500 Server Error');
    }
  }
}
/* ───── Path pattern compiler ───────────────────────────────────────────
   /files/:name  ->  ^/files/([^/]+)$           keys=['name']
   /api/*        ->  ^/api/(.*)$                keys=['*']
------------------------------------------------------------------------ */
function compilePath(pattern: string): { regex: RegExp; keys: string[] } {
  const keys: string[] = [];
  const regexSrc = pattern
    .replace(/\/:(\w+)/g, (_, k) => {
      keys.push(k);
      return '/([^/]+)';
    })
    .replace(/\*/g, () => {
      keys.push('*');
      return '(.*)';
    });
  return { regex: new RegExp(`^${regexSrc}$`), keys };
}
/* ───── Exports ───────────────────────────────────────────────────────── */
export const router = new Router();
// Dynamically load route definitions after router is initialized
// (avoids circular-import issues with static `import '../routes'`)
async function loadRoutesSafely() {
  try {
    await import('../routes');
  } catch (error) {
    console.error('Failed to dynamically import routes:', error);
    // fallback or no-op if needed
  }
}
// Immediately trigger loading
loadRoutesSafely();
export default router;
</file>

<file path="core/server.ts">
import { createServer, Socket } from 'net';
import { HttpRequestParser } from './httpParser';
import { router } from './router';
import { logger } from '../utils/logger';
import { sendResponse } from '../entities/sendResponse';
import { config } from '../config/server.config'; // Assuming config is imported from a config file
export class HttpServer {
  private server = createServer();
  private readonly connections = new Set<Socket>();
  constructor(private port: number) {
    this.setupServer();
  }
  private setupServer() {
    this.server.on('connection', (socket: Socket) => {
      this.connections.add(socket);
      const parser = new HttpRequestParser();
      // --- ⏰ Idle Timeout (Protection) ---
      const HEADER_TIMEOUT_MS = config.headerTimeoutMs;
      const BODY_TIMEOUT_MS = config.bodyTimeoutMs;
      let headerTimer: NodeJS.Timeout | undefined;
      let bodyTimer: NodeJS.Timeout | undefined;
      const refreshTimeout = () => {
        if (headerTimer) clearTimeout(headerTimer);
        headerTimer = setTimeout(() => {
          logger.warn('Closing idle socket (header timeout)');
          socket.destroy();
        }, HEADER_TIMEOUT_MS);
      };
      const refreshBodyTimeout = () => {
        if (bodyTimer) clearTimeout(bodyTimer);
        bodyTimer = setTimeout(() => {
          logger.warn('Closing idle socket (body timeout)');
          socket.destroy();
        }, BODY_TIMEOUT_MS);
      };
      refreshTimeout(); // start immediately
      socket.once('close', () => {
        this.connections.delete(socket);
        if (headerTimer) clearTimeout(headerTimer);
        if (bodyTimer) clearTimeout(bodyTimer);
      });
      logger.info('New connection established.');
      socket.on('data', async (chunk: Buffer) => {
        refreshTimeout();
        try {
          // First feed yields the first complete request (or null)
          let req = parser.feed(chunk);
          if (!req) return; // need more bytes
          clearTimeout(headerTimer);
          // Handle all pipelined requests in buffer
          do {
            // If this is a body-bearing method, start body timeout
            if (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {
              refreshBodyTimeout();
            }
            await router.handle(req, socket);
            clearTimeout(bodyTimer);
            // now pull the next request from any leftover bytes
            req = parser.feed(Buffer.alloc(0));
          } while (req);
          const pending = parser.getPendingBytes();
          if (pending > 0) {
            // more pipelined data waiting—keep alive
            refreshTimeout();
          } else {
            socket.end();
          }
        } catch (err) {
          logger.error(`Failed request: ${(err as Error).message}`);
          sendResponse(socket, 400, { 'Content-Type': 'text/plain' }, 'Bad Request');
        }
      });
      socket.on('error', (err) => {
        logger.error(`Socket error: ${err.message}`);
      });
    });
    this.server.on('error', (err: NodeJS.ErrnoException) => {
      if (err.code === 'EADDRINUSE') {
        this.port += 1; // try the next port
        logger.warn(`Port busy, retrying on ${this.port}`);
        this.server.listen(this.port);
      } else {
        logger.error(`Server error: ${err.message}`);
      }
    });
  }
  /**
   * Gracefully shuts down the server and every open TCP socket.
   */
  public async stop(): Promise<void> {
    logger.info('🛑  Shutting down HTTP server');
    for (const sock of this.connections) sock.destroy();
    await new Promise<void>((resolve, reject) =>
      this.server.close((err) => (err ? reject(err) : resolve())),
    );
  }
  /**
   * Public method to destroy all active sockets.
   */
  public destroySockets(): void {
    this.connections.forEach((socket) => socket.destroy());
  }
  public start() {
    this.server.listen(this.port, () => {
      logger.info(`🚀 Server running at port ${this.port}`);
    });
    // graceful shutdown on Ctrl-C / kill
    ['SIGINT', 'SIGTERM'].forEach((sig) =>
      process.on(sig as NodeJS.Signals, () => {
        this.stop()
          .then(() => process.exit(0))
          .catch(() => process.exit(1));
      }),
    );
    // src/core/server.ts  – inside start() after existing SIGINT/SIGTERM hooks
    ['SIGUSR2'].forEach((sig) =>
      process.once(sig as NodeJS.Signals, () => {
        this.stop().then(() => process.kill(process.pid, sig));
      }),
    );
  }
}
</file>

<file path="entities/http.ts">
export interface IncomingRequest {
  url: URL; // canonical URL (always present)
  path: string; // == url.pathname
  query: Record<string, string>; // decoded single-value map
  httpVersion: string; // e.g. "HTTP/1.1"
  method: string;
  headers: Record<string, string>;
  headersMap?: Map<string, string[]>;
  body?: Buffer;
  raw: string;
  ctx?: Record<string, unknown>;
  invalid?: boolean;
}
</file>

<file path="entities/sendResponse.ts">
import { Socket } from 'net';
import { Readable } from 'stream';
const STATUS_TEXT: Record<number, string> = {
  200: 'OK',
  206: 'Partial Content',
  400: 'Bad Request',
  404: 'Not Found',
  405: 'Method Not Allowed',
  416: 'Range Not Satisfiable', // ← new
  500: 'Internal Server Error',
};
export function sendResponse(
  socket: Socket,
  status: number,
  headers: Record<string, string>,
  body?: string | Buffer | Readable,
): void {
  const head =
    `HTTP/1.1 ${status} ${STATUS_TEXT[status] ?? ''}\r\n` +
    Object.entries(headers)
      .map(([k, v]) => `${k}: ${v}`)
      .join('\r\n') +
    '\r\n\r\n';
  socket.write(head);
  if (!body) {
    // No body: write head only, leave socket open for HttpServer to manage closing
    return;
  }
  if (body instanceof Readable) {
    // Stream without closing socket; HttpServer will close when appropriate
    body.pipe(socket, { end: false });
    body.once('error', () => socket.destroy());
  } else {
    // Write body without closing socket
    socket.write(body);
  }
}
</file>

<file path="modules/file-streamer/fileService.ts">
// file-streamer/fileService.ts
import {
  existsSync,
  createReadStream,
  statSync,
  createWriteStream,
  readdirSync, // ← added for legacy tests
} from 'fs';
import { stat, readdir, mkdir } from 'fs/promises';
import { resolve, join } from 'path';
import { Readable } from 'stream';
import { Socket } from 'net';
import { config } from '../../config/server.config';
import { getMimeType } from '../../utils/helpers';
import { sendResponse } from '../../entities/sendResponse';
export class FileService {
  constructor(private readonly rootDir: string) {}
  private resolveSafe(relPath: string): string {
    const abs = resolve(this.rootDir, relPath);
    if (!abs.startsWith(this.rootDir)) throw new Error('Path traversal attempt');
    return abs;
  }
  /* ---------- modern async API ---------- */
  async listFiles(relDir = '.'): Promise<string[]> {
    return await readdir(this.resolveSafe(relDir));
  }
  async stat(relPath: string) {
    return await stat(this.resolveSafe(relPath));
  }
  async readFile(relPath: string, range?: { start: number; end: number }): Promise<Readable> {
    const abs = this.resolveSafe(relPath);
    return createReadStream(abs, range);
  }
  async saveFile(relPath: string, data: AsyncIterable<Buffer>): Promise<void> {
    const abs = this.resolveSafe(relPath);
    await mkdir(resolve(abs, '..'), { recursive: true });
    const ws = createWriteStream(abs);
    for await (const chunk of data) ws.write(chunk);
    await new Promise<void>((res, rej) => {
      ws.end(res);
      ws.on('error', rej);
    });
  }
  /* ---------- legacy static helpers (keep old tests green) ---------- */
  static listFiles(): { files: string[] } {
    const dir = config.mediaDir;
    if (!existsSync(dir)) return { files: [] };
    return { files: readdirSync(dir) };
  }
  static streamFile(filename: string, rangeHeader: string | undefined, socket: Socket): void {
    const abs = join(config.mediaDir, filename);
    if (!existsSync(abs)) {
      sendResponse(socket, 404, { 'Content-Type': 'text/plain' }, '404 Not Found');
      return;
    }
    const stats = statSync(abs);
    const size = stats.size;
    const start = 0;
    const end = size - 1;
    if (rangeHeader) {
      // Matches bytes=START-END, bytes=START-, bytes=-END
      const m = /bytes=(\d*)-(\d*)/.exec(rangeHeader);
      if (m) {
        const startStr = m[1];
        const endStr = m[2];
        let start: number | undefined;
        let end: number | undefined;
        if (startStr && endStr) {
          // bytes=START-END
          start = parseInt(startStr, 10);
          end = parseInt(endStr, 10);
        } else if (startStr) {
          // bytes=START-
          start = parseInt(startStr, 10);
          end = size - 1;
        } else if (endStr) {
          // bytes=-END
          start = size - parseInt(endStr, 10);
          end = size - 1;
        }
        if (start === undefined || end === undefined || start > end || start >= size) {
          sendResponse(socket, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          return;
        }
      } else {
        sendResponse(socket, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
        return;
      }
    }
    const len = end - start + 1;
    const stream = createReadStream(abs, { start, end });
    const headers = {
      'Content-Type': getMimeType(filename) ?? 'application/octet-stream',
      'Accept-Ranges': 'bytes',
      'Content-Range': `bytes ${start}-${end}/${size}`,
      'Content-Length': String(len),
    };
    sendResponse(socket, 206, headers, stream);
    stream.on('error', () => socket.end());
  }
  /* ------------------------------------------------------------------ */
}
</file>

<file path="modules/file-streamer/fileStreamingController.ts">
import { Socket } from 'net';
import { sendResponse } from '../../entities/sendResponse';
import { IncomingRequest } from '../../entities/http';
import { FileService } from './fileService';
import { getHeader, getQuery } from '../../utils/httpHelpers';
import { config } from '../../config/server.config';
import { logger } from '../../utils/logger';
import { getMimeType } from '../../utils/helpers';
import { Readable } from 'stream';
const fileSvc = new FileService(config.mediaDir);
export const fileStreamingController = {
  /** GET /files – returns JSON list of filenames */
  async listFiles(req: IncomingRequest, sock: Socket) {
    try {
      const files = await fileSvc.listFiles();
      sendResponse(sock, 200, { 'Content-Type': 'application/json' }, JSON.stringify(files));
    } catch (err) {
      logger.error(`listFiles: ${(err as Error).message}`);
      sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, 'Server error');
    }
  },
  /** GET /stream?file=video.mp4 – streams file (supports Range) */
  async handleStream(req: IncomingRequest, sock: Socket) {
    logger.info(
      `[handleStream] url=${req.url} path=${req.path} query=${JSON.stringify(req.query)}`,
    );
    const fileName = getQuery(req, 'file');
    if (!fileName) {
      sendResponse(
        sock,
        400,
        { 'Content-Type': 'text/plain' },
        'Missing required "file" query parameter.',
      );
      return;
    }
    try {
      const rangeHdr = getHeader(req, 'range'); // e.g. "bytes=0-1023"
      let stream: Readable;
      const fileStat = await fileSvc.stat(fileName);
      const size = fileStat.size;
      if (rangeHdr) {
        const m = /bytes=(\d*)-(\d*)/.exec(rangeHdr);
        if (!m) {
          sendResponse(sock, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          sock.end();
          return;
        }
        const startStr = m[1];
        const endStr = m[2];
        let start: number;
        let end: number;
        if (startStr) {
          start = parseInt(startStr, 10);
          end = endStr ? parseInt(endStr, 10) : size - 1;
        } else {
          const suffix = parseInt(endStr, 10);
          start = size - suffix;
          end = size - 1;
        }
        if (start > end || start < 0 || end >= size) {
          sendResponse(sock, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          sock.end();
          return;
        }
        stream = await fileSvc.readFile(fileName, { start, end });
        if (!stream) {
          throw new Error('Stream is undefined');
        }
        stream.on('error', (err) => {
          logger.error(`[handleStream] Stream error: ${err.message}`);
          sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, 'Internal Server Error');
        });
        const len = end - start + 1;
        sendResponse(
          sock,
          206,
          {
            'Content-Type': getMimeType(fileName) || 'application/octet-stream',
            'Accept-Ranges': 'bytes',
            'Content-Range': `bytes ${start}-${end}/${size}`,
            'Content-Length': String(len),
          },
          stream,
        );
      } else {
        stream = await fileSvc.readFile(fileName);
        if (!stream) {
          throw new Error('Stream is undefined');
        }
        stream.on('error', (err) => {
          logger.error(`[handleStream] Stream error: ${err.message}`);
          sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, 'Internal Server Error');
        });
        const mimeType = getMimeType(fileName);
        sendResponse(
          sock,
          200,
          { 'Content-Type': mimeType, 'Content-Length': String(size) },
          stream,
        );
      }
    } catch (err) {
      logger.error(`[handleStream] fileName=${fileName}, error=${(err as Error).message}`);
      sendResponse(sock, 404, { 'Content-Type': 'text/plain' }, `File "${fileName}" not found.`);
    }
  },
};
</file>

<file path="modules/file-streamer/index.ts">
export { FileService } from './fileService';
export { fileStreamingController } from './fileStreamingController';
</file>

<file path="routes/files.routes.ts">
// routes/files.routes.ts
import { router } from '../core/router';
import { fileStreamingController } from '../modules/file-streamer';
router.get('/files', fileStreamingController.listFiles);
</file>

<file path="routes/index.ts">
// routes/index.ts
import './stream.routes';
import './files.routes';
export {}; // side-effect imports run immediately
</file>

<file path="routes/stream.routes.ts">
// routes/stream.routes.ts
import { router } from '../core/router';
import { fileStreamingController } from '../modules/file-streamer';
router.get('/stream', fileStreamingController.handleStream);
</file>

<file path="utils/helpers.ts">
import { extname } from 'path';
import { mimeTypes } from './mimeTypes';
export function getMimeType(fileName: string): string {
  const ext = extname(fileName).toLowerCase();
  return mimeTypes[ext] || 'application/octet-stream';
}
</file>

<file path="utils/httpHelpers.ts">
// Simple header accessor that falls back to legacy Record<string,string>
import { IncomingRequest } from '../entities/http';
/**
 * Case-insensitive lookup that handles multi-value headers.
 * @param req - The incoming request object.
 * @param name - The name of the header to retrieve.
 * @returns The value of the header, or undefined if not found.
 * @example
 * const contentType = getHeader(req, 'Content-Type');
 * const userAgent = getHeader(req, 'User-Agent');
 * const customHeader = getHeader(req, 'X-Custom-Header');
 */
export function getHeader(req: IncomingRequest, name: string): string | undefined {
  const key = name.toLowerCase();
  if (req.headersMap && req.headersMap.has(key)) {
    return req.headersMap.get(key)![0]; // first value
  }
  return req.headers?.[key];
}
/** Case-sensitive query lookup that falls back to searchParams */
export function getQuery(req: IncomingRequest, key: string): string | undefined {
  if (req.invalid || !req.query || !req.url) return undefined;
  // ✅ look in the parser-built map first
  const direct = req.query?.[key];
  if (direct !== undefined) return direct;
  // fallback (rare) – parse from URL
  return req.url.searchParams.get(key) ?? undefined;
}
</file>

<file path="utils/logger.ts">
// src/utils/logger.ts
type LogLevel = 'info' | 'warn' | 'error' | 'debug';
class Logger {
  private getTimestamp(): string {
    return new Date().toISOString();
  }
  private formatMessage(level: LogLevel, message: string): string {
    return `[${this.getTimestamp()}] [${level.toUpperCase()}]: ${message}`;
  }
  info(message: string): void {
    console.log(this.formatMessage('info', message));
  }
  warn(message: string): void {
    console.warn(this.formatMessage('warn', message));
  }
  error(message: string): void {
    console.error(this.formatMessage('error', message));
  }
  debug(message: string): void {
    if (process.env.NODE_ENV === 'development') {
      console.debug(this.formatMessage('debug', message));
    }
  }
}
// Export a singleton instance
export const logger = new Logger();
</file>

<file path="utils/mimeTypes.ts">
export const mimeTypes: Record<string, string> = {
  '.html': 'text/html',
  '.htm': 'text/html',
  '.js': 'application/javascript',
  '.json': 'application/json',
  '.css': 'text/css',
  '.txt': 'text/plain',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.png': 'image/png',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.mp3': 'audio/mpeg',
  '.mp4': 'video/mp4',
  '.webm': 'video/webm',
  '.ogg': 'audio/ogg',
  '.pdf': 'application/pdf',
  '.zip': 'application/zip',
  '.tar': 'application/x-tar',
};
</file>

<file path="main.ts">
// main.ts
import './routes';
import { HttpServer } from './core/server';
import { config } from './config/server.config';
import { logger } from './utils/logger';
logger.info('routes loaded');
const server = new HttpServer(config.port);
server.start();
</file>

<file path="core/httpParser.test.ts">
import { HttpRequestParser } from '../../src/core/httpParser'; // Ensure this file exists or update the path
import { IncomingRequest } from '../../src/entities/http'; // Ensure this file exists or update the path
function feedAll(parser: HttpRequestParser, str: string): IncomingRequest | null {
  return parser.feed(Buffer.from(str, 'utf8'));
}
describe('HttpRequestParser', () => {
  let parser: HttpRequestParser;
  beforeEach(() => {
    parser = new HttpRequestParser();
  });
  test('parses simple GET request', () => {
    const req = feedAll(parser, 'GET /hello HTTP/1.1\r\nHost: example.com\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.method).toBe('GET');
    expect(req?.path).toBe('/hello');
    expect(req?.headers['host']).toBe('example.com');
    expect(req?.invalid).toBeFalsy();
  });
  test('parses POST with Content-Length', () => {
    const req = feedAll(
      parser,
      'POST /submit HTTP/1.1\r\nHost: test\r\nContent-Length: 11\r\n\r\nHello World',
    );
    expect(req).not.toBeNull();
    expect(req?.method).toBe('POST');
    expect(req?.body?.toString()).toBe('Hello World');
  });
  test('handles chunked transfer-encoding', () => {
    const parts = [
      'POST /upload HTTP/1.1\r\nHost: test\r\nTransfer-Encoding: chunked\r\n\r\n',
      '5\r\nHello\r\n',
      '6\r\n World\r\n',
      '0\r\n\r\n',
    ];
    let result: IncomingRequest | null = null;
    for (const p of parts) {
      const feedResult = parser.feed(Buffer.from(p, 'utf8'));
      if (feedResult) result = feedResult;
    }
    if (!result) {
      const feedResult = parser.feed(Buffer.alloc(0));
      if (feedResult) result = feedResult;
    }
    expect(result).not.toBeNull();
    expect(result?.body?.toString()).toBe('Hello World');
  });
  test('rejects invalid request line', () => {
    const req = feedAll(parser, 'BADREQUEST\r\nHost: test\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });
  test('rejects unsupported HTTP method', () => {
    const req = feedAll(parser, 'FOO / HTTP/1.1\r\nHost: test\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });
  test('rejects too many headers', () => {
    const headers = Array(1005).fill('X-Test: 123').join('\r\n');
    const req = feedAll(parser, `GET / HTTP/1.1\r\n${headers}\r\n\r\n`);
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });
  test('rejects body exceeding MAX_BODY_BYTES', () => {
    const bigBody = 'A'.repeat(11 * 1024 * 1024); // 11MB
    const req = feedAll(
      parser,
      `POST / HTTP/1.1\r\nHost: test\r\nContent-Length: ${bigBody.length}\r\n\r\n${bigBody}`,
    );
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });
  test('parses partial requests across multiple TCP chunks', () => {
    const req1 = parser.feed(Buffer.from('GET /mul', 'utf8'));
    expect(req1).toBeNull();
    const req2 = parser.feed(Buffer.from('ti-part HTTP/1.1\r\nHost: te', 'utf8'));
    expect(req2).toBeNull();
    const req3 = parser.feed(Buffer.from('st\r\n\r\n', 'utf8'));
    expect(req3).not.toBeNull();
    expect(req3?.method).toBe('GET');
    expect(req3?.path).toBe('/multi-part');
    expect(req3?.headers['host']).toBe('test');
  });
  test('parses headers with continuations', () => {
    const req = feedAll(
      parser,
      'GET / HTTP/1.1\r\nHost: test\r\nX-Long-Header: abc\r\n def\r\n\r\n',
    );
    expect(req).not.toBeNull();
    expect(req?.headers['x-long-header']).toBe('abc def');
  });
  test('ignores trailers after chunked body', () => {
    const parts = [
      'POST /upload HTTP/1.1\r\nHost: test\r\nTransfer-Encoding: chunked\r\n\r\n',
      '5\r\nHello\r\n',
      '6\r\n World\r\n',
      '0\r\nSome-Trailer: yes\r\n\r\n',
    ];
    let result: IncomingRequest | null = null;
    for (const p of parts) {
      const feedResult = parser.feed(Buffer.from(p, 'utf8'));
      if (feedResult) result = feedResult;
    }
    expect(result).not.toBeNull();
    expect(result?.body?.toString()).toBe('Hello World');
  });
  test('rejects missing Host header in HTTP/1.1', () => {
    const req = feedAll(parser, 'GET /test HTTP/1.1\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });
  test('allows HTTP/1.0 without Host header', () => {
    const req = feedAll(parser, 'GET /test HTTP/1.0\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeFalsy();
  });
});
</file>

<file path="core/parser.test.ts">
import { parser } from '../../src/core/parser';
describe('HTTP Parser', () => {
  it('should parse a simple GET request', () => {
    const raw = 'GET /hello HTTP/1.1\r\nHost: localhost\r\nUser-Agent: test\r\n\r\n';
    const parsed = parser.parse(raw);
    expect(parsed.method).toBe('GET');
    expect(parsed.path).toBe('/hello');
    expect(parsed.httpVersion).toBe('HTTP/1.1');
    expect(parsed.headers.host).toBe('localhost');
    expect(parsed.headers['user-agent']).toBe('test');
  });
  it('should handle missing headers gracefully', () => {
    const raw = 'POST /upload HTTP/1.1\r\n\r\n';
    const parsed = parser.parse(raw);
    expect(parsed.method).toBe('POST');
    expect(parsed.path).toBe('/upload');
    expect(parsed.headers).toEqual({});
  });
  it('should not crash on completely malformed request', () => {
    const raw = 'INVALID REQUEST';
    const parsed = parser.parse(raw);
    expect(parsed.invalid).toBe(true);
    expect(parsed.method).toBeFalsy();
    expect(parsed.path).toBeFalsy();
  });
  it('should parse url.pathname and headersMap correctly', () => {
    const raw = 'GET /hello HTTP/1.1\r\nHost: localhost\r\nUser-Agent: test\r\n\r\n';
    const parsed = parser.parse(raw);
    expect(parsed.url?.pathname).toBe('/hello');
    expect(parsed.headersMap?.get('host')).toEqual(['localhost']);
  });
  it('exposes url, path, and query consistently', () => {
    const raw = 'GET /stream?file=test.mp4 HTTP/1.1\r\nHost: x\r\n\r\n';
    const r = parser.parse(raw);
    expect(r.url.pathname).toBe('/stream');
    expect(r.path).toBe('/stream');
    expect(r.query).toEqual({ file: 'test.mp4' });
  });
  it('includes httpVersion', () => {
    const raw = 'GET /test HTTP/1.1\r\nHost: x\r\n\r\n';
    const r = parser.parse(raw);
    expect(r.httpVersion).toBe('HTTP/1.1');
  });
  it('should handle completely empty request', () => {
    const raw = '';
    const parsed = parser.parse(raw);
    expect(parsed.invalid).toBe(true);
    expect(parsed.method).toBeFalsy();
    expect(parsed.path).toBeFalsy();
    expect(parsed.headers).toEqual({});
  });
  it('should correctly parse multiple query parameters', () => {
    const raw = 'GET /search?q=nodejs&sort=desc HTTP/1.1\r\nHost: localhost\r\n\r\n';
    const parsed = parser.parse(raw);
    expect(parsed.method).toBe('GET');
    expect(parsed.path).toBe('/search');
    expect(parsed.httpVersion).toBe('HTTP/1.1');
    expect(parsed.headers.host).toBe('localhost');
    expect(parsed.query).toEqual({ q: 'nodejs', sort: 'desc' });
  });
  it('should decode percent-encoded paths', () => {
    const raw = 'GET /foo%20bar HTTP/1.1\r\nHost: localhost\r\n\r\n';
    const parsed = parser.parse(raw);
    expect(parsed.path).toBe('/foo bar');
  });
  it('should handle OPTIONS * request', () => {
    const raw = 'OPTIONS * HTTP/1.1\r\nHost: localhost\r\n\r\n';
    const parsed = parser.parse(raw);
    expect(parsed.method).toBe('OPTIONS');
    expect(parsed.path).toBe('*');
  });
  it('should handle duplicated headers gracefully', () => {
    const raw = `GET / HTTP/1.1\r\nHost: localhost\r\nCookie: a=1\r\nCookie: b=2\r\n\r\n`;
    const parsed = parser.parse(raw);
    expect(parsed.headers.host).toBe('localhost');
    expect(parsed.headers['cookie']).toBe('b=2'); // Note: last wins in simple parsing
    expect(parsed.headersMap?.get('cookie')).toEqual(['a=1', 'b=2']);
  });
});
</file>

<file path="core/router.test.ts">
import { router } from '../../src/core/router';
import { IncomingRequest } from '../../src/entities/http';
import { Socket } from 'net';
// Mock the file-streaming controller so router tests stay focused
jest.mock('../../src/modules/file-streamer/fileStreamingController', () => ({
  fileStreamingController: {
    listFiles: jest.fn(async (_req, sock) => {
      sock.write('HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\n');
    }),
    handleStream: jest.fn(async (_req, sock) => {
      sock.write('HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\n');
    }),
  },
}));
describe('Router', () => {
  const fakeSocket = {
    write: jest.fn(),
    end: jest.fn(),
  } as unknown as Socket;
  beforeEach(() => {
    jest.clearAllMocks();
  });
  it('should return 404 for unknown route', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/doesnotexist'),
      method: 'GET',
      path: '/doesnotexist',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };
    await router.handle(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(
      expect.stringContaining('HTTP/1.1 404 Not Found'),
    );
  });
  it('should handle a valid /files GET request', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/files'),
      method: 'GET',
      path: '/files',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };
    await router.handle(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('HTTP/1.1 200 OK'));
  });
  it('should return 405 Method Not Allowed for wrong method', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/files'),
      method: 'POST', // Should be GET
      path: '/files',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };
    await router.handle(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(
      expect.stringContaining('HTTP/1.1 405 Method Not Allowed'),
    );
  });
  it('should handle missing path safely', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/'),
      method: 'GET',
      path: undefined as unknown as string, // force a bad input
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };
    await router.handle(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('400 Bad Request'));
  });
  it('should handle /stream route with file query parameter', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/stream?file=testfile.txt'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: { file: 'testfile.txt' },
    };
    await router.handle(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalled(); // should attempt to stream the requested file
  });
  it('should return 500 if handler throws', async () => {
    router.get('/error', async () => {
      throw new Error('fail');
    });
    const validReq: IncomingRequest = {
      url: new URL('http://localhost/error'),
      method: 'GET',
      path: '/error',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };
    const req = { ...validReq, path: '/error' };
    await router.handle(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('500 Server Error'));
  });
});
</file>

<file path="modules/file-streamer/fileService.test.ts">
import { FileService } from '../../../src/modules/file-streamer/fileService';
import * as fs from 'fs';
import { Socket } from 'net';
jest.mock('fs');
describe('FileService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  describe('listFiles', () => {
    it('should list files when media directory exists', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.readdirSync as jest.Mock).mockReturnValue(['video.mp4', 'audio.mp3']);
      const result = FileService.listFiles();
      expect(result.files).toEqual(['video.mp4', 'audio.mp3']);
    });
    it("should return empty list if media directory doesn't exist", () => {
      (fs.existsSync as jest.Mock).mockReturnValue(false);
      const result = FileService.listFiles();
      expect(result.files).toEqual([]);
    });
  });
  describe('streamFile', () => {
    const fakeSocket = {
      write: jest.fn(),
      end: jest.fn(),
      on: jest.fn(),
      pipe: jest.fn(),
    } as unknown as Socket;
    it('should handle non-existing file gracefully', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(false);
      FileService.streamFile('nofile.mp4', undefined, fakeSocket);
      expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('404 Not Found'));
      // no socket.end(): persistent connections are managed by the server layer
    });
    it('should handle invalid range requests', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      FileService.streamFile('video.mp4', 'bytes=2000-3000', fakeSocket);
      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('416 Range Not Satisfiable'),
      );
      // no socket.end(): connection closing is up to the server
    });
    it('should start a stream for a valid file', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });
      FileService.streamFile('video.mp4', undefined, fakeSocket);
      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });
    it('should handle file stream error', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      const mockStream = {
        pipe: jest.fn(),
        on: jest.fn((event, handler) => {
          if (event === 'error') {
            handler(new Error('Stream failed'));
          }
        }),
      };
      (fs.createReadStream as jest.Mock).mockReturnValue(mockStream);
      FileService.streamFile('video.mp4', undefined, fakeSocket);
      expect(fakeSocket.end).toHaveBeenCalled();
    });
    it('should stream partial content for valid small range', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });
      FileService.streamFile('video.mp4', 'bytes=0-499', fakeSocket);
      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });
    it('should stream partial content for valid range bytes=0-499', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });
      FileService.streamFile('video.mp4', 'bytes=0-499', fakeSocket);
      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });
    it('should handle range with no start (e.g., bytes=-500)', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });
      FileService.streamFile('video.mp4', 'bytes=-500', fakeSocket);
      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });
    it('should handle range with no end (e.g., bytes=500-)', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });
      FileService.streamFile('video.mp4', 'bytes=500-', fakeSocket);
      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });
    it('should return 416 for invalid range format (e.g., bytes=invalid)', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      FileService.streamFile('video.mp4', 'bytes=invalid', fakeSocket);
      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('416 Range Not Satisfiable'),
      );
      // no socket.end(): streaming errors leave connection management to the TCP layer
    });
  });
});
</file>

<file path="modules/file-streamer/fileStreamingController.test.ts">
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-require-imports */
let fileStreamingController: any;
let fs: any;
let fsPromises: any;
let config: any;
import { IncomingRequest } from '../../../src/entities/http';
import { Socket } from 'net';
import { Readable } from 'stream';
jest.mock('fs');
jest.mock('fs/promises');
const fakeStream = new Readable({ read() {} }); // a real Readable stream
// Dynamically load controller after resetting modules and config
describe('fileStreamingController', () => {
  const fakeSocket = {
    write: jest.fn(),
    end: jest.fn(),
  } as unknown as Socket;
  beforeEach(() => {
    jest.resetModules();
    jest.clearAllMocks();
    // require fresh modules after reset
    fs = require('fs');
    fsPromises = require('fs/promises');
    config = require('../../../src/config/server.config').config;
    config.mediaDir = '/mocked/media';
    // mock fs methods
    fs.existsSync.mockReturnValue(true);
    fsPromises.readdir.mockResolvedValue(['video.mp4']);
    fsPromises.stat.mockResolvedValue({ size: 1000, isFile: () => true });
    fs.createReadStream.mockReturnValue(fakeStream);
    // load controller after mocks and config override
    fileStreamingController =
      require('../../../src/modules/file-streamer/fileStreamingController').fileStreamingController;
  });
  it('should respond with 400 if no file param on stream', async () => {
    const req = {
      url: new URL('http://localhost/stream'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    } as IncomingRequest;
    await fileStreamingController.handleStream(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(
      expect.stringContaining('HTTP/1.1 400 Bad Request'),
    );
    expect(fakeSocket.write).toHaveBeenCalledWith(
      expect.stringContaining('Missing required "file"'),
    );
  });
  it('should respond with 404 if file does not exist', async () => {
    // Simulate missing file by having stat reject
    fsPromises.stat.mockRejectedValueOnce(new Error('File not found'));
    const req = {
      url: new URL('http://localhost/stream?file=nonexistent.mp4'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: { file: 'nonexistent.mp4' },
    } as IncomingRequest;
    await fileStreamingController.handleStream(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(
      expect.stringContaining('HTTP/1.1 404 Not Found'),
    );
  });
  it('should list files correctly', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/files'),
      method: 'GET',
      path: '/files',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };
    await fileStreamingController.listFiles(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('HTTP/1.1 200 OK'));
  });
  it('should stream file if it exists', async () => {
    const req = {
      url: new URL('http://localhost/stream?file=video.mp4'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost', range: 'bytes=0-499' },
      raw: '',
      query: { file: 'video.mp4' },
    } as IncomingRequest;
    await fileStreamingController.handleStream(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(
      expect.stringContaining('HTTP/1.1 206 Partial Content'),
    );
    // also assert correct Content-Type header
    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('Content-Type:'));
    expect(fs.createReadStream).toHaveBeenCalledWith(expect.stringContaining('video.mp4'), {
      start: 0,
      end: 499,
    });
  });
});
</file>

<file path="utils/helpers.test.ts">
import { getMimeType } from '../../src/utils/helpers';
describe('Helpers - getMimeType', () => {
  it('should return correct MIME type for mp4', () => {
    expect(getMimeType('movie.mp4')).toBe('video/mp4');
  });
  it('should return correct MIME type for jpg', () => {
    expect(getMimeType('image.jpg')).toBe('image/jpeg');
  });
  it('should return default MIME type for unknown file extension', () => {
    expect(getMimeType('something.unknownext')).toBe('application/octet-stream');
  });
  it('should return default MIME type for file with no extension', () => {
    expect(getMimeType('README')).toBe('application/octet-stream');
  });
});
</file>

<file path="utils/logger.test.ts">
import { logger } from '../../src/utils/logger';
describe('Logger', () => {
  it('should log info messages', () => {
    const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
    logger.info('Hello World');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });
  it('should log warning messages', () => {
    const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
    logger.warn('Watch out!');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });
  it('should log error messages', () => {
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
    logger.error('This is bad!');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });
  it('should conditionally log debug messages', () => {
    process.env.NODE_ENV = 'development';
    const consoleSpy = jest.spyOn(console, 'debug').mockImplementation();
    logger.debug('Debugging...');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
    // restore original NODE_ENV
    delete process.env.NODE_ENV;
  });
  afterEach(() => {
    jest.restoreAllMocks();
  });
});
</file>

<file path="core/http_stress.test.ts">
import { createConnection } from 'net';
import { config } from '../../src/config/server.config'; // assuming your port config
import { HttpServer } from '../../src/core/server';
jest.setTimeout(20000); // Increase timeout for all tests in this file
config.bodyTimeoutMs = 10000; // Set body timeout to 10 seconds
config.headerTimeoutMs = 10000; // Set header timeout to 10 seconds
let server: HttpServer;
beforeAll(async () => {
  server = new HttpServer(config.port);
  server.start();
  // Wait briefly to ensure server is ready
  await new Promise((res) => setTimeout(res, 300));
});
afterEach(() => {
  jest.clearAllTimers();
});
afterAll(async () => {
  await server.stop();
  // Ensure all sockets are closed using the new public method
  server.destroySockets();
});
function sendRawRequest(payload: string | Buffer, expectClose: boolean = true): Promise<string> {
  return new Promise((resolve, reject) => {
    const client = createConnection({ port: config.port }, () => {
      client.write(payload);
    });
    let data = '';
    let timeout: NodeJS.Timeout | null = null;
    client.on('data', (chunk) => {
      data += chunk.toString();
    });
    client.on('end', () => {
      if (timeout) clearTimeout(timeout);
      resolve(data);
    });
    client.on('error', (err) => {
      if (timeout) clearTimeout(timeout);
      reject(err);
    });
    if (!expectClose) {
      timeout = setTimeout(() => client.end(), 3000); // manual timeout fallback
    }
  });
}
describe('🔥 HTTP Server TCP Stress Tests', () => {
  it('handles simple GET properly', async () => {
    const response = await sendRawRequest('GET /files HTTP/1.1\r\nHost: localhost\r\n\r\n');
    expect(response).toMatch(/HTTP\/1\.1 200 OK/);
  });
  it('handles fragmented headers across TCP packets', async () => {
    const sock = createConnection({ port: config.port });
    sock.write('GET /files HT');
    await new Promise((r) => setTimeout(r, 50));
    sock.write('TP/1.1\r\nHo');
    await new Promise((r) => setTimeout(r, 50));
    sock.write('st: localhost\r\n\r\n');
    let response = '';
    sock.on('data', (chunk) => {
      response += chunk.toString();
    });
    const res = await new Promise<string>((resolve) => {
      sock.on('end', () => resolve(response));
    });
    expect(res).toMatch(/HTTP\/1\.1 200 OK/);
  });
  it('handles invalid request line (bad client)', async () => {
    const response = await sendRawRequest('BADREQUEST\r\nHost: localhost\r\n\r\n');
    expect(response).toMatch(/HTTP\/1.1 400 Bad Request/);
  });
  it('rejects massive headers flood', async () => {
    const massiveHeaders = Array(1200).fill('X-Flood: yes').join('\r\n');
    const request = `GET / HTTP/1.1\r\n${massiveHeaders}\r\n\r\n`;
    const response = await sendRawRequest(request);
    expect(response).toMatch(/HTTP\/1.1 400 Bad Request/);
  });
  it('rejects huge body POST (over limit)', async () => {
    const bigBody = 'A'.repeat(12 * 1024 * 1024); // 12MB
    const request = `POST / HTTP/1.1\r\nHost: localhost\r\nContent-Length: ${bigBody.length}\r\n\r\n${bigBody}`;
    const response = await sendRawRequest(request);
    expect(response).toMatch(/HTTP\/1.1 400 Bad Request/);
  });
  it('handles chunked upload streamed slowly', async () => {
    const sock = createConnection({ port: config.port });
    const parts = [
      'POST /upload HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n',
      '5\r\nHello\r\n',
      '6\r\n World\r\n',
      '0\r\n\r\n',
    ];
    for (const p of parts) {
      sock.write(p);
      await new Promise((r) => setTimeout(r, 100));
    }
    let response = '';
    sock.on('data', (chunk) => {
      response += chunk.toString();
    });
    const res = await new Promise<string>((resolve) => {
      sock.on('end', () => resolve(response));
    });
    expect(res).toMatch(/HTTP\/1\.1/);
    expect(res).not.toMatch(/400/);
  });
  // Add a test for header folding
  it('handles folded headers correctly', async () => {
    const foldedHeaderRequest = `GET / HTTP/1.1\r\nHost: localhost\r\nX-Folded: part1\r\n\tpart2\r\n\r\n`;
    const response = await sendRawRequest(foldedHeaderRequest);
    expect(response).toMatch(/HTTP\/1\.1 404 Not Found/);
  });
  it('supports HTTP/1.1 pipelined requests', async () => {
    const payload =
      'GET /files HTTP/1.1\r\nHost: localhost\r\n\r\n' +
      'GET /files HTTP/1.1\r\nHost: localhost\r\n\r\n';
    const response = await sendRawRequest(payload, false);
    const occurrences = (response.match(/HTTP\/1\.1/gi) || []).length;
    expect(occurrences).toBe(2);
  });
});
</file>

</files>
