This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, **/*.json, **/.gitignore, node_modules/**, thumbnails/**, **/dist/**, **/build/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
config/
  server.config.ts
core/
  http_stress.test.ts
  httpParser.test.ts
  httpParser.ts
  parser.test.ts
  parser.ts
  router.test.ts
  router.ts
  server.test.ts
  server.ts
entities/
  http.ts
  sendResponse.ts
modules/
  app-metrics/
    app_gallery-generator/
      index.ts
      metricsController.ts
      metricsService.ts
    index.ts
    metricsController.test.ts
    README.md
  file-hosting/
    fileHostingController.ts
    fileHostingService.ts
    index.ts
  file-streamer/
    fileService.test.ts
    fileStreamingController.test.ts
  file-streaming/
    fileService.ts
    fileStreamingController.ts
    index.ts
routes/
  file-hosting.routes.ts
  files.routes.ts
  index.ts
  metrics.routes.ts
  stream.routes.ts
utils/
  helpers.test.ts
  helpers.ts
  httpHelpers.ts
  logger.test.ts
  logger.ts
  mimeTypes.ts
global.d.ts
main.ts
setupJest.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="config/server.config.ts">
import dotenv from 'dotenv';
import { join } from 'path';
import { logger } from '../utils/logger';

// Load environment variables from .env file
dotenv.config();

export const config = {
  port: process.env.PORT ? parseInt(process.env.PORT, 10) : 3000,
  publicDir: process.env.PUBLIC_DIR
    ? join(process.cwd(), process.env.PUBLIC_DIR)
    : join(process.cwd(), 'public'),
  mediaDir: process.env.MEDIA_DIR
    ? join(process.cwd(), process.env.MEDIA_DIR)
    : join(process.cwd(), 'media'),
  headerTimeoutMs: process.env.HEADER_TIMEOUT_MS
    ? Math.max(parseInt(process.env.HEADER_TIMEOUT_MS, 10), 0)
    : 5000,
  bodyTimeoutMs: process.env.BODY_TIMEOUT_MS
    ? Math.max(parseInt(process.env.BODY_TIMEOUT_MS, 10), 0)
    : 10000,
  /**
   * Path to the SQLite database file. Will be created if missing.
   */
  dbPath: process.env.DB_PATH ? process.env.DB_PATH : join(process.cwd(), 'data', 'metrics.db'),
  /**
   * Feature toggles for modularity and configurability
   */
  features: {
    metrics: true,
    fileHosting: true,
    fileStreaming: true,
    // Add more features here as needed
  },
};

logger.info(`Server configuration:`);
logger.info(`- Port: ${config.port}`);
logger.info(`- Public Directory: ${config.publicDir}`);
logger.info(`- Media Directory: ${config.mediaDir}`);
logger.info(`- Header Timeout: ${config.headerTimeoutMs}ms`);
logger.info(`- Body Timeout: ${config.bodyTimeoutMs}ms`);
logger.info(`- Database Path: ${config.dbPath}`);
</file>

<file path="core/httpParser.ts">
import { IncomingRequest } from '../entities/http';
import { URL } from 'url';
import { logger } from '../utils/logger';

enum ParserState {
  REQUEST_LINE,
  HEADERS,
  BODY,
  CHUNK_SIZE,
  CHUNK_BODY,
  CHUNK_TRAILER,
  DONE,
  ERROR,
}

const ALLOWED_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'];
const MAX_HEADER_BYTES = 8192; // 8KB
const MAX_HEADERS = 100; // Maximum number of headers allowed
const MAX_BODY_BYTES = 10 * 1024 * 1024; // 10 MB
const CRLF = Buffer.from('\r\n');

export class HttpRequestParser {
  protected buffer = Buffer.alloc(0);
  private state = ParserState.REQUEST_LINE;
  private headers: Record<string, string> = {};
  private headersMap = new Map<string, string[]>();
  private bodyChunks: Buffer[] = [];
  private method = '';
  private httpVersion = '';
  private url!: URL;
  private contentLength = 0;
  private remainingBody = 0;
  private isChunked = false;
  private invalid = false;
  private lastHeaderKey: string | null = null;

  /**
   * Returns the number of pending bytes in the parser buffer.
   */
  public getPendingBytes(): number {
    return this.buffer.length;
  }

  feed(data: Buffer): IncomingRequest | null {
    this.buffer = Buffer.concat([this.buffer, data]);
    try {
      while (true) {
        // REQUEST_LINE
        if (this.state === ParserState.REQUEST_LINE) {
          const idx = this.buffer.indexOf('\r\n');
          if (idx === -1) return null;
          const requestLine = this.buffer.subarray(0, idx).toString('utf8');
          this.buffer = this.buffer.subarray(idx + 2);
          const parts = requestLine.split(' ');
          if (parts.length !== 3) {
            this._setError('Invalid request line: ' + requestLine);
            return this._errorResponse();
          }
          const [method, reqPath, version] = parts;
          if (!ALLOWED_METHODS.includes(method)) {
            this._setError('Unsupported method: ' + method);
            continue;
          }
          if (!version.startsWith('HTTP/')) {
            this._setError('Invalid HTTP version: ' + version);
            continue;
          }
          this.method = method;
          this.httpVersion = version;
          try {
            this.url = new URL(reqPath, 'http://placeholder');
          } catch {
            this._setError('Malformed URL: ' + reqPath);
            continue;
          }
          this.state = ParserState.HEADERS;
        }
        // HEADERS
        if (this.state === ParserState.HEADERS) {
          // find end-of-headers or handle empty header block
          const idx = this.buffer.indexOf('\r\n\r\n');
          let headersRaw = '';
          if (idx === -1) {
            // immediate blank line ‚Üí zero headers
            if (this.buffer.subarray(0, 2).equals(CRLF)) {
              this.buffer = this.buffer.subarray(2);
            } else {
              if (this.buffer.length > MAX_HEADER_BYTES) {
                this._setError('Headers too large');
                return this._errorResponse();
              }
              return null;
            }
          } else {
            headersRaw = this.buffer.subarray(0, idx).toString('utf8');
            this.buffer = this.buffer.subarray(idx + 4);
          }
          const lines = headersRaw.split('\r\n');
          let headerCount = 0;
          for (const line of lines) {
            if (line.trim() === '') continue;
            // support folded headers per RFC7230 ¬ß3.2.4
            if (line.startsWith(' ') || line.startsWith('\t')) {
              if (this.lastHeaderKey) {
                const prev = this.headers[this.lastHeaderKey];
                this.headers[this.lastHeaderKey] = prev + ' ' + line.trim();
                // update map too
                this.headersMap.set(
                  this.lastHeaderKey,
                  (this.headersMap.get(this.lastHeaderKey) || []).concat(
                    this.headers[this.lastHeaderKey],
                  ),
                );
                continue;
              } else {
                this._setError('Invalid header folding');
                return this._errorResponse();
              }
            }
            const colon = line.indexOf(':');
            if (colon === -1) {
              this._setError('Invalid header line: ' + line);
              continue;
            }
            const key = line.slice(0, colon).trim().toLowerCase();
            const value = line.slice(colon + 1).trim();
            this.headers[key] = value;
            this.headersMap.set(key, [...(this.headersMap.get(key) ?? []), value]);
            this.lastHeaderKey = key;
            headerCount++;
            if (headerCount > MAX_HEADERS) {
              this._setError('Too many headers');
              return this._errorResponse();
            }
          }
          // Short-circuit on parse errors
          if (this.invalid) {
            return this._errorResponse();
          }
          // enforce Host header for HTTP/1.1
          if (this.httpVersion === 'HTTP/1.1' && !this.headers['host']) {
            this._setError('Missing Host header');
            return this._errorResponse();
          }
          if (
            this.headers['transfer-encoding'] &&
            this.headers['transfer-encoding'].toLowerCase() === 'chunked'
          ) {
            this.isChunked = true;
            this.state = ParserState.CHUNK_SIZE;
          } else if (this.headers['content-length']) {
            this.contentLength = parseInt(this.headers['content-length'], 10);
            if (isNaN(this.contentLength) || this.contentLength < 0) {
              this._setError('Invalid Content-Length');
              continue;
            }
            this.remainingBody = this.contentLength;
            this.state = this.contentLength > 0 ? ParserState.BODY : ParserState.DONE;
          } else {
            this.state = ParserState.DONE;
          }
        }
        // BODY
        if (this.state === ParserState.BODY) {
          this.contentLength = parseInt(this.headers['content-length'], 10);
          if (isNaN(this.contentLength) || this.contentLength < 0) {
            this._setError('Invalid Content-Length');
            continue;
          }
          if (this.contentLength > MAX_BODY_BYTES) {
            this._setError('Request body too large');
            continue;
          }
          this.remainingBody = this.contentLength;
          if (this.buffer.length < this.remainingBody) return null;
          this.bodyChunks.push(this.buffer.subarray(0, this.remainingBody));
          this.buffer = this.buffer.subarray(this.remainingBody);
          this.remainingBody = 0;
          this.state = ParserState.DONE;
        }
        // CHUNK_SIZE
        if (this.state === ParserState.CHUNK_SIZE) {
          const idx = this.buffer.indexOf('\r\n');
          if (idx === -1) return null;
          const line = this.buffer.subarray(0, idx).toString('utf8');
          this.buffer = this.buffer.subarray(idx + 2);
          const chunkSize = parseInt(line, 16);
          if (isNaN(chunkSize)) {
            this._setError('Invalid chunk size: ' + line);
            continue;
          }
          if (chunkSize === 0) {
            this.state = ParserState.CHUNK_TRAILER;
          } else {
            this.remainingBody = chunkSize;
            this.state = ParserState.CHUNK_BODY;
          }
        }
        // CHUNK_BODY
        if (this.state === ParserState.CHUNK_BODY) {
          if (this.remainingBody > MAX_BODY_BYTES) {
            this._setError('Chunk body too large');
            continue;
          }
          if (this.buffer.length < this.remainingBody) return null;
          const chunk = this.buffer.subarray(0, this.remainingBody);
          this.bodyChunks.push(chunk);
          this.buffer = this.buffer.subarray(this.remainingBody);
          this.remainingBody = 0;
          if (this.buffer.length < 2 || !this.buffer.subarray(0, 2).equals(CRLF)) {
            this._setError('Missing CRLF after chunk');
            continue;
          }
          this.buffer = this.buffer.subarray(2);
          this.state = ParserState.CHUNK_SIZE;
        }
        // CHUNK_TRAILER
        if (this.state === ParserState.CHUNK_TRAILER) {
          if (this.buffer.length === 0 || this.buffer.equals(CRLF)) {
            this.buffer = Buffer.alloc(0);
            this.state = ParserState.DONE;
            continue;
          }
          const idx = this.buffer.indexOf('\r\n\r\n');
          if (idx === -1) return null;
          this.buffer = this.buffer.subarray(idx + 4);
          this.state = ParserState.DONE;
        }
        // DONE
        if (this.state === ParserState.DONE) {
          // capture leftover before reset (for pipelining)
          const leftover = this.buffer;
          const finalBody = this.bodyChunks.length ? Buffer.concat(this.bodyChunks) : undefined;
          const request = {
            method: this.method,
            path: this.url.pathname,
            query: Object.fromEntries(this.url.searchParams.entries()),
            headers: this.headers,
            headersMap: this.headersMap,
            httpVersion: this.httpVersion,
            url: this.url,
            body: finalBody,
            raw: '',
            ctx: {},
            invalid: this.invalid,
          };
          this.reset();
          this.buffer = leftover; // restore leftover for next request
          return request;
        }
        // ERROR
        if (this.state === ParserState.ERROR) {
          const errReq = this._errorResponse();
          this.reset();
          return errReq;
        }
      }
    } catch (err) {
      this._setError(`Error during parsing: ${(err as Error).message}`);
      const errReq = this._errorResponse();
      this.reset();
      return errReq;
    }
  }

  private _setError(message: string): void {
    logger.error(message);
    this.invalid = true;
    this.state = ParserState.ERROR;
  }

  /** Build a minimal invalid IncomingRequest */
  private _errorResponse(): IncomingRequest {
    return {
      method: '',
      path: '',
      query: {},
      headers: {},
      headersMap: new Map(),
      httpVersion: '',
      url: new URL('http://invalid'),
      body: undefined,
      raw: '',
      ctx: {},
      invalid: true,
    };
  }

  reset(): void {
    this.buffer = Buffer.alloc(0);
    this.state = ParserState.REQUEST_LINE;
    this.headers = {};
    this.headersMap = new Map();
    this.bodyChunks = [];
    this.method = '';
    this.httpVersion = '';
    this.url = new URL('http://placeholder');
    this.contentLength = 0;
    this.remainingBody = 0;
    this.isChunked = false;
    this.invalid = false;
    this.lastHeaderKey = null;
  }
}
</file>

<file path="core/parser.ts">
import { IncomingRequest } from '../entities/http';
import { URL } from 'url';

const ALLOWED_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'] as const;
const MAX_HEADERS = 1000;

// helper for duplicate headers
function addHeader(map: Map<string, string[]>, key: string, value: string) {
  const k = key.toLowerCase();
  const list = map.get(k) ?? [];
  list.push(value);
  map.set(k, list);
}

export const parser = {
  parse(raw: string): IncomingRequest {
    const dummyUrl = new URL('http://placeholder/');
    const earlyReturn = (): IncomingRequest => ({
      url: dummyUrl,
      path: '',
      query: {},
      httpVersion: '',
      method: '',
      headers: {},
      headersMap: new Map(),
      raw,
      ctx: {},
      invalid: true,
    });

    /* -------- empty buffer guard -------- */
    if (raw.length === 0) return earlyReturn();

    const [head = '', bodyString = ''] = raw.split('\r\n\r\n');
    const lines = head.split('\r\n');

    /* -------- request-line split -------- */
    const [requestLine, ...headerLines] = lines;
    const parts = requestLine.split(' ');
    if (parts.length < 3) return earlyReturn();

    const [method, fullPath, httpVersion] = parts;
    const isOptionsStar = method === 'OPTIONS' && fullPath === '*';
    let invalid =
      !ALLOWED_METHODS.includes(method as (typeof ALLOWED_METHODS)[number]) ||
      (!fullPath.startsWith('/') && !isOptionsStar) ||
      !httpVersion.startsWith('HTTP/');

    /* -------- URL + query -------- */
    const url = isOptionsStar
      ? new URL('http://placeholder')
      : new URL(fullPath, 'http://placeholder');
    const query: Record<string, string> = {};
    url.searchParams.forEach((v, k) => (query[k] = v));

    /* -------- headers -------- */
    const headers: Record<string, string> = {};
    const headersMap = new Map<string, string[]>();

    if (headerLines.length > MAX_HEADERS) invalid = true;

    for (const line of headerLines) {
      const idx = line.indexOf(':');
      if (idx === -1) {
        invalid = true;
        continue;
      }
      const key = line.slice(0, idx).trim();
      const value = line.slice(idx + 1).trim();
      headers[key.toLowerCase()] = value;
      addHeader(headersMap, key, value);
    }

    const body = bodyString ? Buffer.from(bodyString, 'utf-8') : undefined;

    return {
      url,
      path: isOptionsStar ? '*' : decodeURIComponent(url.pathname),
      query,
      httpVersion,
      method,
      headers,
      headersMap,
      body,
      raw,
      ctx: {},
      invalid,
    };
  },
};
</file>

<file path="core/router.ts">
// src/core/router.ts
import { Socket } from 'net';
import { IncomingRequest } from '../entities/http';
import { sendResponse } from '../entities/sendResponse';
import { logger } from '../utils/logger';

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Types ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

export type Handler = (req: IncomingRequest, sock: Socket) => Promise<void> | void;
export type Middleware = (
  req: IncomingRequest,
  sock: Socket,
  next: () => Promise<void>,
) => Promise<void> | void;

interface Route {
  method: string; // 'GET' | 'POST' | 'ANY'
  regex: RegExp; // compiled path matcher
  keys: string[]; // param names (for :id stuff)
  handler: Handler;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Router implementation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

class Router {
  private middlewares: Middleware[] = [];
  private routes: Route[] = [];

  /* ---------- Middleware ---------- */
  use(mw: Middleware) {
    this.middlewares.push(mw);
  }

  /* ---------- Route registration helpers ---------- */
  add(method: string, path: string, handler: Handler) {
    const { regex, keys } = compilePath(path);
    this.routes.push({ method: method.toUpperCase(), regex, keys, handler });
  }
  get(path: string, h: Handler) {
    this.add('GET', path, h);
  }
  post(path: string, h: Handler) {
    this.add('POST', path, h);
  }
  put(path: string, h: Handler) {
    this.add('PUT', path, h);
  }
  del(path: string, h: Handler) {
    this.add('DELETE', path, h);
  }
  any(path: string, h: Handler) {
    this.add('ANY', path, h);
  }

  /* ---------- Main entry ---------- */
  async handle(req: IncomingRequest, sock: Socket): Promise<void> {
    if (req.method === 'OPTIONS') {
      sendResponse(
        sock,
        200,
        { 'Content-Type': 'text/plain', Allow: 'GET, POST, PUT, DELETE, OPTIONS' },
        'OK',
      );
      return;
    }
    if (!req.path || typeof req.path !== 'string') {
      sendResponse(
        sock,
        400,
        {
          'Content-Type':
            req.path && req.path.startsWith('/api/') ? 'application/json' : 'text/plain',
        },
        req.path && req.path.startsWith('/api/')
          ? JSON.stringify({ error: 'Bad Request' })
          : 'Bad Request',
      );
      return;
    }
    logger.info(`router saw ${req.method} ${req.path}`);
    // 1. run middleware chain
    let i = 0;
    const self = this;
    // Use an explicit stack to unwind after handler
    const run = async (): Promise<void> => {
      if (i < self.middlewares.length) {
        const idx = i++;
        await self.middlewares[idx](req, sock, run);
        return;
      }
      // Only after all middleware, run the handler
      // 2. route lookup
      const matching = self.routes.filter((r) => r.regex.test(req.path));
      const route =
        matching.find((r) => r.method === req.method) ?? matching.find((r) => r.method === 'ANY');
      if (!route) {
        // Distinguish 404 vs 405
        if (matching.length) {
          // Only include allowed methods that are not 'ANY'
          const allowed = matching
            .map((r) => r.method)
            .filter((m) => m !== 'ANY')
            .join(', ');
          if (req.path.startsWith('/api/')) {
            sendResponse(
              sock,
              405,
              {
                'Content-Type': 'application/json',
                Allow: allowed,
              },
              JSON.stringify({ error: 'Method Not Allowed' }),
            );
          } else {
            sendResponse(sock, 405, { Allow: allowed }, 'Method Not Allowed');
          }
        } else {
          if (req.path.startsWith('/api/')) {
            sendResponse(
              sock,
              404,
              { 'Content-Type': 'application/json' },
              JSON.stringify({ error: 'Not Found' }),
            );
          } else {
            sendResponse(sock, 404, { 'Content-Type': 'text/plain' }, 'Not Found');
          }
        }
        return;
      }
      // 3. pull params (/:id etc.) ‚Üí req.ctx.params
      const match = route.regex.exec(req.path)!;
      const params: Record<string, string> = {};
      route.keys.forEach((k, idx) => {
        params[k] = decodeURIComponent(match[idx + 1]);
      });
      (req.ctx ??= {}).params = params;
      // 4. invoke handler
      try {
        await route.handler(req, sock);
      } catch (err) {
        logger.error(`Handler error: ${(err as Error).message}`);
        if (req.path.startsWith('/api/')) {
          sendResponse(
            sock,
            500,
            { 'Content-Type': 'application/json' },
            JSON.stringify({ error: 'Internal Server Error' }),
          );
        } else {
          sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, '500 Server Error');
        }
      }
    };
    try {
      await run();
    } catch (err) {
      // Global error handler for middleware
      if (req.path.startsWith('/api/')) {
        sendResponse(
          sock,
          500,
          { 'Content-Type': 'application/json' },
          JSON.stringify({ error: 'Internal Server Error' }),
        );
      } else {
        sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, '500 Server Error');
      }
      logger.error(`Middleware error: ${(err as Error).message}`);
      return;
    }
  }
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Path pattern compiler ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   /files/:name  ->  ^/files/([^/]+)$           keys=['name']
   /api/*        ->  ^/api/(.*)$                keys=['*']
------------------------------------------------------------------------ */
function compilePath(pattern: string): { regex: RegExp; keys: string[] } {
  const keys: string[] = [];
  const regexSrc = pattern
    .replace(/\/:(\w+)/g, (_, k) => {
      keys.push(k);
      return '/([^/]+)';
    })
    .replace(/\*/g, () => {
      keys.push('*');
      return '(.*)';
    });
  return { regex: new RegExp(`^${regexSrc}$`), keys };
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Exports ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

export function createRouter(): Router {
  return new Router();
}

export default createRouter();
</file>

<file path="core/server.ts">
import { createServer, Socket } from 'net';
import { HttpRequestParser } from './httpParser';
import router from './router';
import { logger } from '../utils/logger';
import { sendResponse } from '../entities/sendResponse';
import { config } from '../config/server.config'; // Assuming config is imported from a config file

export class HttpServer {
  private server = createServer();
  private readonly connections = new Set<Socket>();
  private readonly router;

  constructor(
    private port: number,
    routerInstance = router,
  ) {
    this.router = routerInstance;
    this.setupServer();
  }

  private setupServer() {
    this.server.on('connection', (socket: Socket) => {
      this.connections.add(socket);
      const parser = new HttpRequestParser();

      // --- ‚è∞ Idle Timeout (Protection) ---
      const HEADER_TIMEOUT_MS = config.headerTimeoutMs;
      const BODY_TIMEOUT_MS = config.bodyTimeoutMs;
      let headerTimer: NodeJS.Timeout | undefined;
      let bodyTimer: NodeJS.Timeout | undefined;

      const refreshTimeout = () => {
        if (headerTimer) clearTimeout(headerTimer);
        headerTimer = setTimeout(() => {
          logger.warn('Closing idle socket (header timeout)');
          socket.destroy();
        }, HEADER_TIMEOUT_MS);
      };

      const refreshBodyTimeout = () => {
        if (bodyTimer) clearTimeout(bodyTimer);
        bodyTimer = setTimeout(() => {
          logger.warn('Closing idle socket (body timeout)');
          socket.destroy();
        }, BODY_TIMEOUT_MS);
      };

      refreshTimeout(); // start immediately

      socket.once('close', () => {
        this.connections.delete(socket);
        if (headerTimer) clearTimeout(headerTimer);
        if (bodyTimer) clearTimeout(bodyTimer);
      });
      logger.info('New connection established.');
      socket.on('data', async (chunk: Buffer) => {
        refreshTimeout();
        try {
          // First feed yields the first complete request (or null)
          let req = parser.feed(chunk);
          if (!req) return; // need more bytes

          clearTimeout(headerTimer);

          // Handle all pipelined requests in buffer
          do {
            // If this is a body-bearing method, start body timeout
            if (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {
              refreshBodyTimeout();
            }

            await this.router.handle(req, socket);
            clearTimeout(bodyTimer);

            // now pull the next request from any leftover bytes
            req = parser.feed(Buffer.alloc(0));
          } while (req);

          const pending = parser.getPendingBytes();
          if (pending > 0) {
            // more pipelined data waiting‚Äîkeep alive
            refreshTimeout();
          } else {
            socket.end();
          }
        } catch (err) {
          logger.error(`Failed request: ${(err as Error).message}`);
          sendResponse(socket, 400, { 'Content-Type': 'text/plain' }, 'Bad Request');
        }
      });

      socket.on('error', (err) => {
        logger.error(`Socket error: ${err.message}`);
      });
    });

    this.server.on('error', (err: NodeJS.ErrnoException) => {
      if (err.code === 'EADDRINUSE') {
        this.port += 1; // try the next port
        logger.warn(`Port busy, retrying on ${this.port}`);
        this.server.listen(this.port);
      } else {
        logger.error(`Server error: ${err.message}`);
      }
    });
  }

  /**
   * Gracefully shuts down the server and every open TCP socket.
   */
  public async stop(): Promise<void> {
    logger.info('üõë  Shutting down HTTP server');
    for (const sock of this.connections) sock.destroy();
    await new Promise<void>((resolve, reject) =>
      this.server.close((err) => (err ? reject(err) : resolve())),
    );
  }

  /**
   * Public method to destroy all active sockets.
   */
  public destroySockets(): void {
    this.connections.forEach((socket) => socket.destroy());
  }

  public start() {
    this.server.listen(this.port, () => {
      logger.info(`üöÄ Server running at port ${this.port}`);
    });

    // graceful shutdown on Ctrl-C / kill
    ['SIGINT', 'SIGTERM'].forEach((sig) =>
      process.on(sig as NodeJS.Signals, () => {
        this.stop()
          .then(() => process.exit(0))
          .catch(() => process.exit(1));
      }),
    );

    // src/core/server.ts  ‚Äì inside start() after existing SIGINT/SIGTERM hooks
    ['SIGUSR2'].forEach((sig) =>
      process.once(sig as NodeJS.Signals, () => {
        this.stop().then(() => process.kill(process.pid, sig));
      }),
    );
  }
}
</file>

<file path="entities/http.ts">
export interface IncomingRequest {
  url: URL; // canonical URL (always present)
  path: string; // == url.pathname
  query: Record<string, string>; // decoded single-value map
  httpVersion: string; // e.g. "HTTP/1.1"

  method: string;
  headers: Record<string, string>;
  headersMap?: Map<string, string[]>;
  body?: Buffer;
  raw: string;
  ctx?: Record<string, unknown>;
  invalid?: boolean;
}
</file>

<file path="entities/sendResponse.ts">
import { Socket } from 'net';
import { Readable } from 'stream';

const STATUS_TEXT: Record<number, string> = {
  200: 'OK',
  206: 'Partial Content',
  400: 'Bad Request',
  404: 'Not Found',
  405: 'Method Not Allowed',
  416: 'Range Not Satisfiable', // ‚Üê new
  500: 'Internal Server Error',
};

export function sendResponse(
  socket: Socket,
  status: number,
  headers: Record<string, string>,
  body?: string | Buffer | Readable,
): void {
  const head =
    `HTTP/1.1 ${status} ${STATUS_TEXT[status] ?? ''}\r\n` +
    Object.entries(headers)
      .map(([k, v]) => `${k}: ${v}`)
      .join('\r\n') +
    '\r\n\r\n';

  socket.write(head);

  if (!body) {
    // No body: write head only, leave socket open for HttpServer to manage closing
    return;
  }

  if (body instanceof Readable) {
    // Stream without closing socket; HttpServer will close when appropriate
    body.pipe(socket, { end: false });
    body.once('error', () => socket.destroy());
  } else {
    // Write body without closing socket
    socket.write(body);
  }
}
</file>

<file path="modules/app-metrics/app_gallery-generator/index.ts">
export * from './metricsController';
export * from './metricsService';
</file>

<file path="modules/app-metrics/app_gallery-generator/metricsController.ts">
import { IncomingRequest } from '../../../entities/http';
import { sendResponse } from '../../../entities/sendResponse';
import { Socket } from 'net';
import { saveMetrics, isPerfLogArray } from './metricsService';
import { logger } from '../../../utils/logger';

export const metricsController = {
  handleMetrics: async (req: IncomingRequest, sock: Socket) => {
    try {
      if (req.method !== 'POST') {
        sendResponse(
          sock,
          405,
          {
            'Content-Type': 'text/plain',
          },
          'Method Not Allowed',
        );
        return;
      }
      let payload: unknown;
      try {
        payload = JSON.parse(
          typeof req.body === 'string' ? req.body : req.body?.toString() || '{}',
        );
      } catch (err) {
        logger.info(`[metrics] Invalid JSON: ${err}`);
        sendResponse(
          sock,
          400,
          { 'Content-Type': 'application/json' },
          JSON.stringify({ error: 'Invalid JSON', details: String(err) }),
        );
        return;
      }
      const clientSessionId = req.headers['x-session-id'] || req.headers['X-Session-Id'];
      // PerfLog batch shortcut
      if (Array.isArray(payload) && isPerfLogArray(payload)) {
        await saveMetrics(payload, undefined, clientSessionId);
        sendResponse(
          sock,
          200,
          { 'Content-Type': 'application/json' },
          JSON.stringify({ status: 'ok' }),
        );
        return;
      }
      // Always call saveMetrics, even if partially invalid
      await saveMetrics(payload, undefined, clientSessionId);
      sendResponse(
        sock,
        200,
        { 'Content-Type': 'application/json' },
        JSON.stringify({ status: 'ok' }),
      );
    } catch (err) {
      logger.info(`[metrics] error saving payload: ${err}`);
      sendResponse(
        sock,
        500,
        {
          'Content-Type': 'text/plain',
        },
        'Internal Server Error',
      );
    }
  },
};
</file>

<file path="modules/app-metrics/app_gallery-generator/metricsService.ts">
import { z } from 'zod';
import sqlite3 from 'sqlite3';
import { open, Database } from 'sqlite';
import { config } from '../../../config/server.config';
import { logger } from '../../../utils/logger';
import fs from 'fs';
import path from 'path';

// --- Zod Schemas ---
const PerfLogEntrySchema = z
  .object({
    timestamp: z.string(),
    perfNow: z.number(),
    memory: z
      .object({
        usedJSHeapSize: z.number().optional(),
        totalJSHeapSize: z.number().optional(),
        jsHeapSizeLimit: z.number().optional(),
      })
      .optional()
      .nullable(), // allow null as well as undefined
    action: z.string(),
    sessionId: z.string().optional(),
    batchId: z.number().optional(),
    uploadMode: z.string().optional(),
  })
  .catchall(z.unknown());

const EngagementStatsSchema = z.object({
  views: z.number(),
  lastViewedAt: z.number(),
  totalWatchMs: z.number(),
  completions: z.number(),
});
const EngagementMapSchema = z.record(EngagementStatsSchema);

const DebugLogSchema = z.object({
  message: z.string(),
  timestamp: z.string(),
});
const DebugLogsSchema = z.array(DebugLogSchema);

const SessionMetricsSchema = z.object({
  sessionId: z.string(),
  startTime: z.number(),
  firstClickTime: z.number().optional(),
  scrollDistance: z.number(),
  itemsLoaded: z.number(),
  infiniteScrollLoads: z.number(),
  hoverThumbnails: z.number(),
  gridClickOpenCount: z.number(),
  modalsOpened: z.number(),
  modalTotalTime: z.number(),
  carouselNavigationCount: z.number(),
  modalContentCounts: z.object({
    video: z.number(),
    image: z.number(),
  }),
  videoMetrics: z.object({
    plays: z.number(),
    completions: z.number(),
    watchTime: z.number(),
    manualStarts: z.number(),
    autoPlays: z.number(),
  }),
  performanceMetrics: z.object({
    preloadDurations: z.array(z.number()),
    longTasks: z.number(),
    infiniteLoadTimes: z.array(z.number()),
    modalAnimationLatencies: z.array(z.number()),
  }),
});

const FullPayloadSchema = z
  .object({
    engagement: EngagementMapSchema,
    perfLog: z.array(PerfLogEntrySchema),
    debug: DebugLogsSchema,
    timestamp: z.string(),
    sessionStart: z.number(),
    sessionMetrics: SessionMetricsSchema,
  })
  .catchall(z.unknown());

export type PerfLogEntry = z.infer<typeof PerfLogEntrySchema>;
export type FullPayload = z.infer<typeof FullPayloadSchema>;

// Export metricsPayloadSchema for controller usage
export const metricsPayloadSchema = FullPayloadSchema;

// Type guard for PerfLogEntry array
export function isPerfLogArray(arr: unknown): arr is PerfLogEntry[] {
  return Array.isArray(arr) && arr.every((item) => PerfLogEntrySchema.safeParse(item).success);
}

// --- DB Setup ---
let db: Database | null = null;
export async function initDb(): Promise<Database> {
  if (db) return db;
  const dbDir = path.dirname(config.dbPath);
  if (!fs.existsSync(dbDir)) {
    fs.mkdirSync(dbDir, { recursive: true });
    logger.info(`Created database directory at ${dbDir}`);
  }
  if (!fs.existsSync(config.dbPath)) {
    fs.closeSync(fs.openSync(config.dbPath, 'w'));
    logger.info(`Created new SQLite database file at ${config.dbPath}`);
  }
  db = await open({ filename: config.dbPath, driver: sqlite3.Database });
  await db.exec(`
    CREATE TABLE IF NOT EXISTS sessions (
      id TEXT PRIMARY KEY,
      timestamp TEXT,
      sessionStart INTEGER
    );
    CREATE TABLE IF NOT EXISTS engagement (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      sessionId TEXT,
      itemId TEXT,
      views INTEGER,
      lastViewedAt INTEGER,
      totalWatchMs INTEGER,
      completions INTEGER,
      FOREIGN KEY(sessionId) REFERENCES sessions(id)
    );
    CREATE TABLE IF NOT EXISTS perfLog (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      sessionId TEXT,
      timestamp TEXT,
      perfNow REAL,
      usedJSHeapSize INTEGER,
      totalJSHeapSize INTEGER,
      jsHeapSizeLimit INTEGER,
      action TEXT,
      batchId INTEGER,
      uploadMode TEXT,
      details TEXT,
      FOREIGN KEY(sessionId) REFERENCES sessions(id)
    );
    CREATE TABLE IF NOT EXISTS debug (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      sessionId TEXT,
      message TEXT,
      timestamp TEXT,
      FOREIGN KEY(sessionId) REFERENCES sessions(id)
    );
    CREATE TABLE IF NOT EXISTS sessionMetrics (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      sessionId TEXT,
      data TEXT,
      FOREIGN KEY(sessionId) REFERENCES sessions(id)
    );
  `);
  return db;
}

// --- Utility: Accept and log all valid data, never reject whole request ---
function logInvalid(type: string, data: unknown, error: unknown) {
  logger.info(
    `[metrics] Invalid ${type}: ${JSON.stringify(error)} | Data: ${JSON.stringify(data)}`,
  );
}

// --- Session Helper ---
async function ensureSessionExists(
  database: Database,
  sessionId: string,
  timestamp?: string,
  sessionStart?: number,
) {
  // Try to find session by id
  const sessionRow = await database.get('SELECT id FROM sessions WHERE id = ?', sessionId);
  if (!sessionRow) {
    await database.run(
      'INSERT INTO sessions (id, timestamp, sessionStart) VALUES (?, ?, ?)',
      sessionId,
      timestamp || new Date().toISOString(),
      sessionStart ?? null,
    );
    logger.info(`[metrics] Created minimal session for id=${sessionId}`);
  }
}

export async function saveMetrics(
  payload: unknown,
  sessionMetrics?: unknown,
  clientSessionId?: string,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _env?: unknown,
) {
  const database = await initDb();
  // PerfLog batch
  if (Array.isArray(payload)) {
    for (const entry of payload) {
      const result = PerfLogEntrySchema.safeParse(entry);
      if (!result.success) {
        logInvalid('perfLog', entry, result.error.format());
        continue;
      }
      // Resolve sessionId
      const resolvedSessionId = result.data.sessionId || clientSessionId;
      if (!resolvedSessionId) {
        logger.warn('[metrics] No sessionId found for perfLog entry. Skipping.');
        continue;
      }
      await ensureSessionExists(database, resolvedSessionId, result.data.timestamp);
      const { timestamp, perfNow, memory, action, batchId, uploadMode, ...rest } = result.data;
      const details = JSON.stringify({ ...rest });
      await database.run(
        `INSERT INTO perfLog (sessionId, timestamp, perfNow, usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit, action, batchId, uploadMode, details)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        resolvedSessionId,
        timestamp,
        perfNow,
        memory?.usedJSHeapSize ?? -1,
        memory?.totalJSHeapSize ?? -1,
        memory?.jsHeapSizeLimit ?? -1,
        action,
        batchId ?? null,
        uploadMode ?? null,
        details,
      );
    }
    return;
  }
  // Full payload
  const result = FullPayloadSchema.safeParse(payload);
  if (!result.success) {
    logInvalid('fullPayload', payload, result.error.format());
    // Try to salvage valid subfields
    if (payload && typeof payload === 'object') {
      // Try perfLog
      const perfLogArray = Array.isArray((payload as Record<string, unknown>).perfLog)
        ? ((payload as Record<string, unknown>).perfLog as unknown[])
        : [];
      for (const entry of perfLogArray) {
        const perfResult = PerfLogEntrySchema.safeParse(entry);
        if (perfResult.success) {
          const { timestamp, perfNow, memory, action, batchId, uploadMode, ...rest } =
            perfResult.data;
          const details = JSON.stringify({ ...rest });
          await database.run(
            `INSERT INTO perfLog (sessionId, timestamp, perfNow, usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit, action, batchId, uploadMode, details)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            null,
            timestamp,
            perfNow,
            memory?.usedJSHeapSize ?? -1,
            memory?.totalJSHeapSize ?? -1,
            memory?.jsHeapSizeLimit ?? -1,
            action,
            batchId ?? null,
            uploadMode ?? null,
            details,
          );
        } else {
          logInvalid('perfLog', entry, perfResult.error.format());
        }
      }
      // Try debug
      const debugArray = Array.isArray((payload as Record<string, unknown>).debug)
        ? ((payload as Record<string, unknown>).debug as unknown[])
        : [];
      for (const entry of debugArray) {
        const debugResult = DebugLogSchema.safeParse(entry);
        if (debugResult.success) {
          await database.run(
            `INSERT INTO debug (sessionId, message, timestamp) VALUES (?, ?, ?)`,
            null,
            debugResult.data.message,
            debugResult.data.timestamp,
          );
        } else {
          logInvalid('debug', entry, debugResult.error.format());
        }
      }
      // Try engagement
      const engagementObj = (payload as Record<string, unknown>).engagement;
      if (engagementObj && typeof engagementObj === 'object' && !Array.isArray(engagementObj)) {
        for (const [itemId, stats] of Object.entries(engagementObj)) {
          const statsResult = EngagementStatsSchema.safeParse(stats);
          if (statsResult.success) {
            await database.run(
              `INSERT INTO engagement (sessionId, itemId, views, lastViewedAt, totalWatchMs, completions) VALUES (?, ?, ?, ?, ?, ?)`,
              null,
              itemId,
              statsResult.data.views,
              statsResult.data.lastViewedAt,
              statsResult.data.totalWatchMs,
              statsResult.data.completions,
            );
          } else {
            logInvalid('engagement', stats, statsResult.error.format());
          }
        }
      }
    }
    return;
  }
  const {
    engagement,
    perfLog,
    debug,
    timestamp,
    sessionStart,
    sessionMetrics: sessionMetricsFromPayload,
  } = result.data;
  // Resolve sessionId
  const resolvedSessionId = sessionMetricsFromPayload.sessionId || clientSessionId;
  await ensureSessionExists(
    database,
    resolvedSessionId || 'unknown-session',
    timestamp,
    sessionStart,
  );
  // Insert engagement
  for (const [itemId, stats] of Object.entries(engagement)) {
    await database.run(
      `INSERT INTO engagement (sessionId, itemId, views, lastViewedAt, totalWatchMs, completions) VALUES (?, ?, ?, ?, ?, ?)`,
      resolvedSessionId,
      itemId,
      stats.views,
      stats.lastViewedAt,
      stats.totalWatchMs,
      stats.completions,
    );
  }
  // Insert perfLog
  for (const entry of perfLog) {
    const { timestamp, perfNow, memory, action, batchId, uploadMode, ...rest } = entry;
    const details = JSON.stringify({ ...rest });
    await database.run(
      `INSERT INTO perfLog (sessionId, timestamp, perfNow, usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit, action, batchId, uploadMode, details) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      resolvedSessionId,
      timestamp,
      perfNow,
      memory?.usedJSHeapSize ?? -1,
      memory?.totalJSHeapSize ?? -1,
      memory?.jsHeapSizeLimit ?? -1,
      action,
      batchId ?? null,
      uploadMode ?? null,
      details,
    );
  }
  // Insert debug
  for (const entry of debug) {
    await database.run(
      `INSERT INTO debug (sessionId, message, timestamp) VALUES (?, ?, ?)`,
      resolvedSessionId,
      entry.message,
      entry.timestamp,
    );
  }
  // Insert sessionMetrics
  await database.run(
    `INSERT INTO sessionMetrics (sessionId, data) VALUES (?, ?)`,
    resolvedSessionId,
    JSON.stringify(sessionMetricsFromPayload),
  );
}

// Graceful shutdown
process.on('SIGINT', async () => {
  if (db) await db.close();
  logger.info('SQLite connection closed (SIGINT)');
  process.exit(0);
});
process.on('SIGTERM', async () => {
  if (db) await db.close();
  logger.info('SQLite connection closed (SIGTERM)');
  process.exit(0);
});
</file>

<file path="modules/app-metrics/index.ts">
export * as appGalleryGenerator from './app_gallery-generator';
</file>

<file path="modules/app-metrics/README.md">
# App Metrics Module

This module provides a structure for collecting and exposing metrics for different applications within the Central Hub project.

## Structure

- Each app has its own subfolder under `app-metrics/` (e.g., `app_gallery-generator/`).
- Each subfolder contains its own controller, service, and index.ts for modularity.
- The main `index.ts` re-exports all app metrics modules.

## Adding Metrics for a New App

1. **Create a new folder:**
   - Example: `src/modules/app-metrics/my_new_app/`
2. **Add your controller and service:**
   - `metricsController.ts` and `metricsService.ts`
3. **Export from `index.ts`:**
   - `export * from './metricsController';`
   - `export * from './metricsService';`
4. **Register the endpoint:**

   - In `src/routes/metrics.routes.ts`, add:

     ```typescript
     import { myNewAppMetricsController } from '../modules/app-metrics/my_new_app/metricsController';
     if (config.features.metrics) {
       router.post('/api/metrics/my-new-app', myNewAppMetricsController.handleMetrics);
     }
     ```

## Feature Toggling

- Metrics endpoints are only registered if `config.features.metrics` is enabled in `src/config/server.config.ts`.
- To disable all metrics endpoints, set `metrics: false` in the config.

## Example Folder Structure

```
src/modules/app-metrics/
  app_gallery-generator/
    metricsController.ts
    metricsService.ts
    index.ts
  my_new_app/
    metricsController.ts
    metricsService.ts
    index.ts
  index.ts
  README.md
```

## Best Practices

- Use RESTful route patterns: `/api/metrics/:app`.
- Keep each app‚Äôs metrics logic isolated in its own folder.
- Document new endpoints in the main README and provide usage examples.
</file>

<file path="modules/file-hosting/fileHostingController.ts">
// src/modules/file-hosting/fileHostingController.ts
import { Socket } from 'net';
import { sendResponse } from '../../entities/sendResponse';
import { IncomingRequest } from '../../entities/http';
import { FileHostingService } from './fileHostingService';
import { getHeader, getQuery } from '../../utils/httpHelpers';
import { config } from '../../config/server.config';
import { logger } from '../../utils/logger';
import { getMimeType } from '../../utils/helpers';
import { Readable } from 'stream';

const fileSvc = new FileHostingService(config.mediaDir);

export const fileHostingController = {
  /** GET /file?file=filename ‚Äì serves a file (supports Range) */
  async getFile(req: IncomingRequest, sock: Socket) {
    logger.info(`[getFile] url=${req.url} path=${req.path} query=${JSON.stringify(req.query)}`);
    const fileName = getQuery(req, 'file');
    if (!fileName) {
      sendResponse(
        sock,
        400,
        { 'Content-Type': 'text/plain' },
        'Missing required "file" query parameter.',
      );
      return;
    }
    try {
      const rangeHdr = getHeader(req, 'range');
      let stream: Readable;
      const fileStat = await fileSvc.stat(fileName);
      const size = fileStat.size;
      if (rangeHdr) {
        const m = /bytes=(\d*)-(\d*)/.exec(rangeHdr);
        if (!m) {
          sendResponse(sock, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          sock.end();
          return;
        }
        const startStr = m[1];
        const endStr = m[2];
        let start: number;
        let end: number;
        if (startStr) {
          start = parseInt(startStr, 10);
          end = endStr ? parseInt(endStr, 10) : size - 1;
        } else {
          const suffix = parseInt(endStr, 10);
          start = size - suffix;
          end = size - 1;
        }
        if (start > end || start < 0 || end >= size) {
          sendResponse(sock, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          sock.end();
          return;
        }
        stream = await fileSvc.readFile(fileName, { start, end });
        if (!stream) throw new Error('Stream is undefined');
        stream.on('error', (err: Error) => {
          logger.error(`[getFile] Stream error: ${err.message}`);
          sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, 'Internal Server Error');
        });
        const len = end - start + 1;
        sendResponse(
          sock,
          206,
          {
            'Content-Type': getMimeType(fileName) || 'application/octet-stream',
            'Accept-Ranges': 'bytes',
            'Content-Range': `bytes ${start}-${end}/${size}`,
            'Content-Length': String(len),
          },
          stream,
        );
      } else {
        stream = await fileSvc.readFile(fileName);
        if (!stream) throw new Error('Stream is undefined');
        stream.on('error', (err: Error) => {
          logger.error(`[getFile] Stream error: ${err.message}`);
          sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, 'Internal Server Error');
        });
        const mimeType = getMimeType(fileName);
        sendResponse(
          sock,
          200,
          { 'Content-Type': mimeType, 'Content-Length': String(size) },
          stream,
        );
      }
    } catch (err: unknown) {
      logger.error(`[getFile] fileName=${fileName}, error=${(err as Error).message}`);
      sendResponse(sock, 404, { 'Content-Type': 'text/plain' }, `File "${fileName}" not found.`);
    }
  },

  /** GET /files ‚Äì returns JSON list of filenames */
  async listFiles(req: IncomingRequest, sock: Socket) {
    try {
      const files = await fileSvc.listFiles();
      sendResponse(sock, 200, { 'Content-Type': 'application/json' }, JSON.stringify(files));
    } catch (err: unknown) {
      logger.error(`listFiles: ${(err as Error).message}`);
      sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, 'Server error');
    }
  },

  /** POST /file ‚Äì upload a media file */
  async uploadFile(req: IncomingRequest, sock: Socket) {
    // Assume fileName is provided as a query param or header, and body is the file data
    const fileName = getQuery(req, 'file') || req.headers['x-filename'];
    if (!fileName) {
      sendResponse(sock, 400, { 'Content-Type': 'text/plain' }, 'Missing file name');
      return;
    }
    const mimeType = getMimeType(fileName);
    if (
      !mimeType.startsWith('image/') &&
      !mimeType.startsWith('video/') &&
      !mimeType.startsWith('audio/')
    ) {
      sendResponse(sock, 400, { 'Content-Type': 'text/plain' }, 'Only media files allowed');
      return;
    }
    if (!req.body) {
      sendResponse(sock, 400, { 'Content-Type': 'text/plain' }, 'No file data');
      return;
    }
    // Save file using FileHostingService
    const fileSvc = new FileHostingService(config.mediaDir);
    // Convert Buffer or string to async iterable
    async function* bufferToAsyncIterable(buffer: Buffer) {
      yield buffer;
    }
    const data = typeof req.body === 'string' ? Buffer.from(req.body) : req.body;
    await fileSvc.saveFile(fileName, bufferToAsyncIterable(data));
    sendResponse(sock, 200, { 'Content-Type': 'text/plain' }, 'Upload successful');
  },

  /** DELETE /file?file=filename ‚Äì delete a media file */
  async deleteFile(req: IncomingRequest, sock: Socket) {
    const fileName = getQuery(req, 'file');
    if (!fileName) {
      sendResponse(sock, 400, { 'Content-Type': 'text/plain' }, 'Missing file name');
      return;
    }
    const fileSvc = new FileHostingService(config.mediaDir);
    const absPath = fileSvc['resolveSafe'](fileName);
    try {
      await import('fs/promises').then((fs) => fs.unlink(absPath));
      sendResponse(sock, 200, { 'Content-Type': 'text/plain' }, 'File deleted');
    } catch {
      sendResponse(
        sock,
        404,
        { 'Content-Type': 'text/plain' },
        'File not found or could not be deleted',
      );
    }
  },
};
</file>

<file path="modules/file-hosting/fileHostingService.ts">
import { existsSync, createReadStream, statSync, createWriteStream, readdirSync } from 'fs';
import { stat, readdir, mkdir } from 'fs/promises';
import { resolve } from 'path';
import { Readable } from 'stream';

export class FileHostingService {
  constructor(private readonly rootDir: string) {}

  private resolveSafe(relPath: string): string {
    const abs = resolve(this.rootDir, relPath);
    if (!abs.startsWith(this.rootDir)) throw new Error('Path traversal attempt');
    return abs;
  }

  async listFiles(relDir = '.'): Promise<string[]> {
    return await readdir(this.resolveSafe(relDir));
  }

  async stat(relPath: string) {
    return await stat(this.resolveSafe(relPath));
  }

  async readFile(relPath: string, range?: { start: number; end: number }): Promise<Readable> {
    const abs = this.resolveSafe(relPath);
    return createReadStream(abs, range);
  }

  async saveFile(relPath: string, data: AsyncIterable<Buffer>): Promise<void> {
    const abs = this.resolveSafe(relPath);
    await mkdir(resolve(abs, '..'), { recursive: true });
    const ws = createWriteStream(abs);
    for await (const chunk of data) ws.write(chunk);
    await new Promise<void>((res, rej) => {
      ws.end(res);
      ws.on('error', rej);
    });
  }
}
</file>

<file path="modules/file-hosting/index.ts">
// src/modules/file-hosting/index.ts
export * from './fileHostingController';
export * from './fileHostingService';
</file>

<file path="modules/file-streaming/fileService.ts">
// file-streamer/fileService.ts
/**
 * @deprecated This file is now obsolete after moving to file-hosting module.
 * This file is deprecated and should be removed. All file management logic is now in file-hosting/fileHostingService.ts.
 */
export class FileService {
  constructor(private readonly rootDir: string) {
    throw new Error('FileService is deprecated. Use file-hosting module instead.');
  }
}
</file>

<file path="modules/file-streaming/fileStreamingController.ts">
import { Socket } from 'net';
import { sendResponse } from '../../entities/sendResponse';
import { IncomingRequest } from '../../entities/http';
import { getHeader, getQuery } from '../../utils/httpHelpers';
import { config } from '../../config/server.config';
import { logger } from '../../utils/logger';
import { getMimeType } from '../../utils/helpers';
import { Readable } from 'stream';
import { FileHostingService } from '../file-hosting/fileHostingService';

const fileSvc = new FileHostingService(config.mediaDir);

export const fileStreamingController = {
  /** GET /stream?file=video.mp4 ‚Äì streams file (supports Range) */
  async handleStream(req: IncomingRequest, sock: Socket) {
    logger.info(
      `[handleStream] url=${req.url} path=${req.path} query=${JSON.stringify(req.query)}`,
    );
    const fileName = getQuery(req, 'file');
    if (!fileName) {
      sendResponse(
        sock,
        400,
        { 'Content-Type': 'text/plain' },
        'Missing required "file" query parameter.',
      );
      return;
    }
    try {
      const rangeHdr = getHeader(req, 'range');
      let stream: Readable;
      const fileStat = await fileSvc.stat(fileName);
      const size = fileStat.size;
      if (rangeHdr) {
        const m = /bytes=(\d*)-(\d*)/.exec(rangeHdr);
        if (!m) {
          sendResponse(sock, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          sock.end();
          return;
        }
        const startStr = m[1];
        const endStr = m[2];
        let start: number;
        let end: number;
        if (startStr) {
          start = parseInt(startStr, 10);
          end = endStr ? parseInt(endStr, 10) : size - 1;
        } else {
          const suffix = parseInt(endStr, 10);
          start = size - suffix;
          end = size - 1;
        }
        if (start > end || start < 0 || end >= size) {
          sendResponse(sock, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          sock.end();
          return;
        }
        stream = await fileSvc.readFile(fileName, { start, end });
        if (!stream) throw new Error('Stream is undefined');
        stream.on('error', (err) => {
          logger.error(`[handleStream] Stream error: ${err.message}`);
          sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, 'Internal Server Error');
        });
        const len = end - start + 1;
        sendResponse(
          sock,
          206,
          {
            'Content-Type': getMimeType(fileName) || 'application/octet-stream',
            'Accept-Ranges': 'bytes',
            'Content-Range': `bytes ${start}-${end}/${size}`,
            'Content-Length': String(len),
          },
          stream,
        );
      } else {
        stream = await fileSvc.readFile(fileName);
        if (!stream) throw new Error('Stream is undefined');
        stream.on('error', (err) => {
          logger.error(`[handleStream] Stream error: ${err.message}`);
          sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, 'Internal Server Error');
        });
        const mimeType = getMimeType(fileName);
        sendResponse(
          sock,
          200,
          { 'Content-Type': mimeType, 'Content-Length': String(size) },
          stream,
        );
      }
    } catch (err) {
      logger.error(`[handleStream] fileName=${fileName}, error=${(err as Error).message}`);
      sendResponse(sock, 404, { 'Content-Type': 'text/plain' }, `File "${fileName}" not found.`);
    }
  },
};
</file>

<file path="modules/file-streaming/index.ts">
export * from './fileService';
export * from './fileStreamingController';
</file>

<file path="routes/file-hosting.routes.ts">
import router from '../core/router';
import { fileHostingController } from '../modules/file-hosting';

// List all files
router.get('/api/files', fileHostingController.listFiles);
// Upload a file
router.post('/api/files', fileHostingController.uploadFile);
// Get a specific file
router.get('/api/files/:filename', fileHostingController.getFile);
// Delete a specific file
router.del('/api/files/:filename', fileHostingController.deleteFile);
</file>

<file path="routes/files.routes.ts">
// routes/files.routes.ts
// This file is now handled by file-hosting.routes.ts for all /api/files endpoints.
import router from '../core/router';
import { fileHostingController } from '../modules/file-hosting';

router.get('/files', fileHostingController.listFiles);
</file>

<file path="routes/index.ts">
// routes/index.ts
import './stream.routes';
import './files.routes';
import './metrics.routes';
import './file-hosting.routes';
import router from '../core/router';
import { sendResponse } from '../entities/sendResponse';

router.any('/echo', async (req, sock) => {
  let message = 'Hello, world!';
  try {
    const b = req.body ? JSON.parse(req.body.toString()) : {};
    if (typeof b?.message === 'string') message = b.message;
  } catch {
    /* empty */
  }
  const res = JSON.stringify({ message });
  sendResponse(
    sock,
    200,
    {
      'Content-Type': 'application/json',
      'Content-Length': Buffer.byteLength(res).toString(),
    },
    res,
  );
});

export {}; // side-effect imports run immediately
</file>

<file path="routes/metrics.routes.ts">
// routes/metrics.routes.ts
import router from '../core/router';
import { metricsController } from '../modules/app-metrics/app_gallery-generator';
import { config } from '../config/server.config';

/**
 * Accepts the JSON payload, validates, and writes into SQLite.
 */
if (config.features.metrics) {
  router.post('/metrics/gallery-generator', metricsController.handleMetrics);
}
</file>

<file path="routes/stream.routes.ts">
// routes/stream.routes.ts
import router from '../core/router';
import { fileStreamingController } from '../modules/file-streaming';
import { config } from '../config/server.config';

if (config.features.fileStreaming) {
  router.get('/api/stream', fileStreamingController.handleStream);
}
</file>

<file path="utils/helpers.ts">
import { extname } from 'path';
import { mimeTypes } from './mimeTypes';

export function getMimeType(fileName: string): string {
  const ext = extname(fileName).toLowerCase();
  return mimeTypes[ext] || 'application/octet-stream';
}
</file>

<file path="utils/httpHelpers.ts">
// Simple header accessor that falls back to legacy Record<string,string>
import { IncomingRequest } from '../entities/http';

/**
 * Case-insensitive lookup that handles multi-value headers.
 * @param req - The incoming request object.
 * @param name - The name of the header to retrieve.
 * @returns The value of the header, or undefined if not found.
 * @example
 * const contentType = getHeader(req, 'Content-Type');
 * const userAgent = getHeader(req, 'User-Agent');
 * const customHeader = getHeader(req, 'X-Custom-Header');
 */
export function getHeader(req: IncomingRequest, name: string): string | undefined {
  const key = name.toLowerCase();
  if (req.headersMap && req.headersMap.has(key)) {
    return req.headersMap.get(key)![0]; // first value
  }
  return req.headers?.[key];
}

/** Case-sensitive query lookup that falls back to searchParams */
export function getQuery(req: IncomingRequest, key: string): string | undefined {
  if (req.invalid || !req.query || !req.url) return undefined;

  // ‚úÖ look in the parser-built map first
  const direct = req.query?.[key];
  if (direct !== undefined) return direct;

  // fallback (rare) ‚Äì parse from URL
  return req.url.searchParams.get(key) ?? undefined;
}
</file>

<file path="utils/logger.ts">
// src/utils/logger.ts

type LogLevel = 'info' | 'warn' | 'error' | 'debug';

class Logger {
  private getTimestamp(): string {
    return new Date().toISOString();
  }

  private formatMessage(level: LogLevel, message: string): string {
    return `[${this.getTimestamp()}] [${level.toUpperCase()}]: ${message}`;
  }

  info(message: string): void {
    console.log(this.formatMessage('info', message));
  }

  warn(message: string): void {
    console.warn(this.formatMessage('warn', message));
  }

  error(message: string): void {
    console.error(this.formatMessage('error', message));
  }

  debug(message: string): void {
    if (process.env.NODE_ENV === 'development') {
      console.debug(this.formatMessage('debug', message));
    }
  }
}

// Export a singleton instance
export const logger = new Logger();
</file>

<file path="utils/mimeTypes.ts">
export const mimeTypes: Record<string, string> = {
  '.html': 'text/html',
  '.htm': 'text/html',
  '.js': 'application/javascript',
  '.json': 'application/json',
  '.css': 'text/css',
  '.txt': 'text/plain',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.png': 'image/png',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.mp3': 'audio/mpeg',
  '.mp4': 'video/mp4',
  '.webm': 'video/webm',
  '.ogg': 'audio/ogg',
  '.pdf': 'application/pdf',
  '.zip': 'application/zip',
  '.tar': 'application/x-tar',
};
</file>

<file path="main.ts">
// main.ts
import './routes';
import { HttpServer } from './core/server';
import { config } from './config/server.config';
import { logger } from './utils/logger';
logger.info('routes loaded');

const server = new HttpServer(config.port);
server.start();
</file>

<file path="core/httpParser.test.ts">
import { HttpRequestParser } from '../../src/core/httpParser'; // Ensure this file exists or update the path
import { IncomingRequest } from '../../src/entities/http'; // Ensure this file exists or update the path

function feedAll(parser: HttpRequestParser, str: string): IncomingRequest | null {
  return parser.feed(Buffer.from(str, 'utf8'));
}

describe('HttpRequestParser', () => {
  let parser: HttpRequestParser;

  beforeEach(() => {
    parser = new HttpRequestParser();
  });

  test('parses simple GET request', () => {
    const req = feedAll(parser, 'GET /hello HTTP/1.1\r\nHost: example.com\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.method).toBe('GET');
    expect(req?.path).toBe('/hello');
    expect(req?.headers['host']).toBe('example.com');
    expect(req?.invalid).toBeFalsy();
  });

  test('parses POST with Content-Length', () => {
    const req = feedAll(
      parser,
      'POST /submit HTTP/1.1\r\nHost: test\r\nContent-Length: 11\r\n\r\nHello World',
    );
    expect(req).not.toBeNull();
    expect(req?.method).toBe('POST');
    expect(req?.body?.toString()).toBe('Hello World');
  });

  test('handles chunked transfer-encoding', () => {
    const parts = [
      'POST /upload HTTP/1.1\r\nHost: test\r\nTransfer-Encoding: chunked\r\n\r\n',
      '5\r\nHello\r\n',
      '6\r\n World\r\n',
      '0\r\n\r\n',
    ];
    let result: IncomingRequest | null = null;
    for (const p of parts) {
      const feedResult = parser.feed(Buffer.from(p, 'utf8'));
      if (feedResult) result = feedResult;
    }
    if (!result) {
      const feedResult = parser.feed(Buffer.alloc(0));
      if (feedResult) result = feedResult;
    }
    expect(result).not.toBeNull();
    expect(result?.body?.toString()).toBe('Hello World');
  });

  test('rejects invalid request line', () => {
    const req = feedAll(parser, 'BADREQUEST\r\nHost: test\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });

  test('rejects unsupported HTTP method', () => {
    const req = feedAll(parser, 'FOO / HTTP/1.1\r\nHost: test\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });

  test('rejects too many headers', () => {
    const headers = Array(1005).fill('X-Test: 123').join('\r\n');
    const req = feedAll(parser, `GET / HTTP/1.1\r\n${headers}\r\n\r\n`);
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });

  test('rejects body exceeding MAX_BODY_BYTES', () => {
    const bigBody = 'A'.repeat(11 * 1024 * 1024); // 11MB
    const req = feedAll(
      parser,
      `POST / HTTP/1.1\r\nHost: test\r\nContent-Length: ${bigBody.length}\r\n\r\n${bigBody}`,
    );
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });

  test('parses partial requests across multiple TCP chunks', () => {
    const req1 = parser.feed(Buffer.from('GET /mul', 'utf8'));
    expect(req1).toBeNull();

    const req2 = parser.feed(Buffer.from('ti-part HTTP/1.1\r\nHost: te', 'utf8'));
    expect(req2).toBeNull();

    const req3 = parser.feed(Buffer.from('st\r\n\r\n', 'utf8'));
    expect(req3).not.toBeNull();
    expect(req3?.method).toBe('GET');
    expect(req3?.path).toBe('/multi-part');
    expect(req3?.headers['host']).toBe('test');
  });

  test('parses headers with continuations', () => {
    const req = feedAll(
      parser,
      'GET / HTTP/1.1\r\nHost: test\r\nX-Long-Header: abc\r\n def\r\n\r\n',
    );
    expect(req).not.toBeNull();
    expect(req?.headers['x-long-header']).toBe('abc def');
  });

  test('ignores trailers after chunked body', () => {
    const parts = [
      'POST /upload HTTP/1.1\r\nHost: test\r\nTransfer-Encoding: chunked\r\n\r\n',
      '5\r\nHello\r\n',
      '6\r\n World\r\n',
      '0\r\nSome-Trailer: yes\r\n\r\n',
    ];
    let result: IncomingRequest | null = null;
    for (const p of parts) {
      const feedResult = parser.feed(Buffer.from(p, 'utf8'));
      if (feedResult) result = feedResult;
    }
    expect(result).not.toBeNull();
    expect(result?.body?.toString()).toBe('Hello World');
  });

  test('rejects missing Host header in HTTP/1.1', () => {
    const req = feedAll(parser, 'GET /test HTTP/1.1\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeTruthy();
  });

  test('allows HTTP/1.0 without Host header', () => {
    const req = feedAll(parser, 'GET /test HTTP/1.0\r\n\r\n');
    expect(req).not.toBeNull();
    expect(req?.invalid).toBeFalsy();
  });
});
</file>

<file path="core/parser.test.ts">
import { parser } from '../../src/core/parser';

describe('HTTP Parser', () => {
  it('should parse a simple GET request', () => {
    const raw = 'GET /hello HTTP/1.1\r\nHost: localhost\r\nUser-Agent: test\r\n\r\n';
    const parsed = parser.parse(raw);

    expect(parsed.method).toBe('GET');
    expect(parsed.path).toBe('/hello');
    expect(parsed.httpVersion).toBe('HTTP/1.1');
    expect(parsed.headers.host).toBe('localhost');
    expect(parsed.headers['user-agent']).toBe('test');
  });

  it('should handle missing headers gracefully', () => {
    const raw = 'POST /upload HTTP/1.1\r\n\r\n';
    const parsed = parser.parse(raw);

    expect(parsed.method).toBe('POST');
    expect(parsed.path).toBe('/upload');
    expect(parsed.headers).toEqual({});
  });

  it('should not crash on completely malformed request', () => {
    const raw = 'INVALID REQUEST';
    const parsed = parser.parse(raw);

    expect(parsed.invalid).toBe(true);
    expect(parsed.method).toBeFalsy();
    expect(parsed.path).toBeFalsy();
  });

  it('should parse url.pathname and headersMap correctly', () => {
    const raw = 'GET /hello HTTP/1.1\r\nHost: localhost\r\nUser-Agent: test\r\n\r\n';
    const parsed = parser.parse(raw);

    expect(parsed.url?.pathname).toBe('/hello');
    expect(parsed.headersMap?.get('host')).toEqual(['localhost']);
  });

  it('exposes url, path, and query consistently', () => {
    const raw = 'GET /stream?file=test.mp4 HTTP/1.1\r\nHost: x\r\n\r\n';
    const r = parser.parse(raw);
    expect(r.url.pathname).toBe('/stream');
    expect(r.path).toBe('/stream');
    expect(r.query).toEqual({ file: 'test.mp4' });
  });

  it('includes httpVersion', () => {
    const raw = 'GET /test HTTP/1.1\r\nHost: x\r\n\r\n';
    const r = parser.parse(raw);
    expect(r.httpVersion).toBe('HTTP/1.1');
  });

  it('should handle completely empty request', () => {
    const raw = '';
    const parsed = parser.parse(raw);

    expect(parsed.invalid).toBe(true);
    expect(parsed.method).toBeFalsy();
    expect(parsed.path).toBeFalsy();
    expect(parsed.headers).toEqual({});
  });

  it('should correctly parse multiple query parameters', () => {
    const raw = 'GET /search?q=nodejs&sort=desc HTTP/1.1\r\nHost: localhost\r\n\r\n';
    const parsed = parser.parse(raw);
    expect(parsed.method).toBe('GET');
    expect(parsed.path).toBe('/search');
    expect(parsed.httpVersion).toBe('HTTP/1.1');
    expect(parsed.headers.host).toBe('localhost');
    expect(parsed.query).toEqual({ q: 'nodejs', sort: 'desc' });
  });

  it('should decode percent-encoded paths', () => {
    const raw = 'GET /foo%20bar HTTP/1.1\r\nHost: localhost\r\n\r\n';
    const parsed = parser.parse(raw);
    expect(parsed.path).toBe('/foo bar');
  });

  it('should handle OPTIONS * request', () => {
    const raw = 'OPTIONS * HTTP/1.1\r\nHost: localhost\r\n\r\n';
    const parsed = parser.parse(raw);
    expect(parsed.method).toBe('OPTIONS');
    expect(parsed.path).toBe('*');
  });

  it('should handle duplicated headers gracefully', () => {
    const raw = `GET / HTTP/1.1\r\nHost: localhost\r\nCookie: a=1\r\nCookie: b=2\r\n\r\n`;
    const parsed = parser.parse(raw);

    expect(parsed.headers.host).toBe('localhost');
    expect(parsed.headers['cookie']).toBe('b=2'); // Note: last wins in simple parsing
    expect(parsed.headersMap?.get('cookie')).toEqual(['a=1', 'b=2']);
  });
});
</file>

<file path="core/router.test.ts">
// __tests__/router.test.ts
import { Socket } from 'net';
import { createRouter } from '../../src/core/router';
import { sendResponse } from '../../src/entities/sendResponse';
import { logger } from '../../src/utils/logger';
import type { IncomingRequest } from '../../src/entities/http';

jest.mock('../../src/entities/sendResponse');
jest.mock('../../src/utils/logger');

describe('Router', () => {
  let router;
  let socket: Socket;
  let req: IncomingRequest;

  beforeEach(() => {
    router = createRouter();

    socket = {
      write: jest.fn(),
      end: jest.fn(),
      destroy: jest.fn(),
    } as unknown as Socket;

    req = {
      method: 'GET',
      path: '/test',
      query: {},
      httpVersion: 'HTTP/1.1',
      headers: {},
      headersMap: new Map(),
      url: new URL('http://localhost/test'),
      raw: '',
      ctx: {},
      invalid: false,
    };
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('should run middleware in sequence', async () => {
    const order: string[] = [];
    router.use(async (_req, _sock, next) => {
      order.push('mw1');
      await next();
      order.push('mw1-after');
    });
    router.use(async (_req, _sock, next) => {
      order.push('mw2');
      await next();
      order.push('mw2-after');
    });

    router.any('/test', async () => {
      order.push('handler');
    });
    await router.handle(req, socket);

    expect(order).toEqual(['mw1', 'mw2', 'handler', 'mw2-after', 'mw1-after']);
  });

  test('should call matching handler for GET route', async () => {
    const handler = jest.fn();
    router.get('/test', handler);

    await router.handle(req, socket);
    expect(handler).toHaveBeenCalledWith(req, socket);
  });

  test('should respond with 404 if no route matches', async () => {
    req.path = '/unknown';
    await router.handle(req, socket);

    expect(sendResponse).toHaveBeenCalledWith(
      socket,
      404,
      { 'Content-Type': 'text/plain' },
      'Not Found',
    );
  });

  test('should respond with 405 if method does not match', async () => {
    req.method = 'POST';
    router.get('/test', jest.fn());

    await router.handle(req, socket);

    expect(sendResponse).toHaveBeenCalledWith(socket, 405, { Allow: 'GET' }, 'Method Not Allowed');
  });

  test('should extract params into req.ctx.params', async () => {
    const paramHandler = jest.fn();
    router.get('/users/:id', paramHandler);

    req.path = '/users/123';
    req.url = new URL('http://localhost/users/123');

    await router.handle(req, socket);
    expect(paramHandler).toHaveBeenCalled();
    expect(req.ctx?.params).toEqual({ id: '123' });
  });

  test('should respond with 500 on handler error', async () => {
    router.get('/error', () => {
      throw new Error('fail');
    });

    req.path = '/error';
    req.url = new URL('http://localhost/error');

    await router.handle(req, socket);

    expect(sendResponse).toHaveBeenCalledWith(
      socket,
      500,
      { 'Content-Type': 'text/plain' },
      '500 Server Error',
    );
  });

  test('should respond to OPTIONS with Allow header', async () => {
    req.method = 'OPTIONS';
    req.path = '/anything';

    await router.handle(req, socket);
    expect(sendResponse).toHaveBeenCalledWith(
      socket,
      200,
      { 'Content-Type': 'text/plain', Allow: 'GET, POST, PUT, DELETE, OPTIONS' },
      'OK',
    );
  });
});
</file>

<file path="core/server.test.ts">
import { createServer, Socket } from 'net';
import { HttpServer } from '../../src/core/server';
import { sendResponse } from '../../src/entities/sendResponse';
import { logger } from '../../src/utils/logger';
import { config } from '../../src/config/server.config';
import * as RouterModule from '../../src/core/router';
import { HttpRequestParser } from '../../src/core/httpParser';

jest.mock('net');
jest.mock('../../src/utils/logger');
jest.mock('../../src/entities/sendResponse');
jest.mock('../../src/config/server.config', () => ({
  config: {
    headerTimeoutMs: 100,
    bodyTimeoutMs: 100,
  },
}));

describe('HttpServer', () => {
  let server: HttpServer;
  let mockSocket: Socket;
  let mockNetServer: any;
  let parserInstance: any;
  let realRouter: any;

  beforeEach(() => {
    jest.clearAllMocks();

    mockSocket = {
      on: jest.fn(),
      once: jest.fn(),
      write: jest.fn(),
      end: jest.fn(),
      destroy: jest.fn(),
    } as unknown as Socket;

    parserInstance = new HttpRequestParser();

    mockNetServer = {
      on: jest.fn(),
      listen: jest.fn(),
      close: jest.fn((cb: () => void) => cb()),
    };
    (createServer as jest.Mock).mockReturnValue(mockNetServer);

    realRouter = RouterModule.createRouter();
    jest.spyOn(realRouter, 'handle').mockImplementation(jest.fn());
    server = new HttpServer(3000, realRouter);
  });

  test('should listen on provided port', () => {
    server.start();
    expect(mockNetServer.listen).toHaveBeenCalledWith(3000, expect.any(Function));
  });

  test('should destroy sockets on stop()', async () => {
    const destroySpy = jest.spyOn(mockSocket, 'destroy');
    (server as any).connections.add(mockSocket);

    await server.stop();

    expect(destroySpy).toHaveBeenCalled();
    expect(mockNetServer.close).toHaveBeenCalled();
  });

  test('should handle incoming connection and process data', async () => {
    let dataHandler;
    mockSocket.on = jest.fn().mockImplementation((event, cb) => {
      if (event === 'data') dataHandler = cb;
    });
    mockSocket.once = jest.fn();

    const connHandler = mockNetServer.on.mock.calls.find(([evt]) => evt === 'connection')[1];
    connHandler(mockSocket);

    const handleSpy = jest.spyOn(realRouter, 'handle');

    dataHandler(Buffer.from('GET / HTTP/1.1\r\nHost: localhost\r\n\r\n'));
    expect(handleSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        method: 'GET',
        path: '/',
        invalid: false,
      }),
      mockSocket,
    );
  });

  test('should destroy socket on header timeout', () => {
    let timeoutFn;
    global.setTimeout = jest.fn((fn) => {
      timeoutFn = fn;
      return 123;
    }) as any;
    global.clearTimeout = jest.fn();

    mockSocket.once = jest.fn();
    mockSocket.on = jest.fn();

    const connHandler = mockNetServer.on.mock.calls.find(([evt]) => evt === 'connection')[1];
    connHandler(mockSocket);

    expect(setTimeout).toHaveBeenCalled();
    expect(typeof timeoutFn).toBe('function');

    timeoutFn(); // simulate timeout trigger
    expect(mockSocket.destroy).toHaveBeenCalled();
  });

  test('should destroy socket on body timeout for POST request', async () => {
    let dataHandler;
    mockSocket.on = jest.fn().mockImplementation((event, cb) => {
      if (event === 'data') dataHandler = cb;
    });
    mockSocket.once = jest.fn();

    const connHandler = mockNetServer.on.mock.calls.find(([evt]) => evt === 'connection')[1];
    connHandler(mockSocket);

    let bodyTimeoutFn;
    global.setTimeout = jest.fn((fn) => {
      if (!bodyTimeoutFn) bodyTimeoutFn = fn;
      return 123;
    }) as any;
    global.clearTimeout = jest.fn();

    dataHandler(Buffer.from('POST / HTTP/1.1\r\n\r\n'));

    expect(typeof bodyTimeoutFn).toBe('function');
    bodyTimeoutFn(); // simulate body timeout
    expect(mockSocket.destroy).toHaveBeenCalled();
  });

  test('should handle multiple pipelined requests in sequence', async () => {
    let dataHandler;
    mockSocket.on = jest.fn().mockImplementation((event, cb) => {
      if (event === 'data') dataHandler = cb;
    });
    mockSocket.once = jest.fn();

    const connHandler = mockNetServer.on.mock.calls.find(([evt]) => evt === 'connection')[1];
    connHandler(mockSocket);

    const handleSpy = jest.spyOn(realRouter, 'handle');

    dataHandler(Buffer.from('GET /first HTTP/1.1\r\n\r\n'));
    dataHandler(Buffer.from('GET /second HTTP/1.1\r\n\r\n'));

    expect(handleSpy).toHaveBeenCalledTimes(2);
  });
});
</file>

<file path="modules/app-metrics/metricsController.test.ts">
import { router } from '../../../src/core/router';
import { config } from '../../../src/config/server.config';
import { Socket } from 'net';
import { IncomingRequest } from '../../../src/entities/http'; // Adjust the path as needed

describe('Metrics Endpoint (gallery-generator)', () => {
  let originalMetricsFeature: boolean;

  beforeAll(() => {
    // Save and enable metrics feature for tests
    originalMetricsFeature = config.features.metrics;
    config.features.metrics = true;
  });

  afterAll(() => {
    // Restore original config
    config.features.metrics = originalMetricsFeature;
  });

  it('should accept a valid POST and return 200', async () => {
    // Mock request and socket
    const req: IncomingRequest = {
      method: 'POST',
      path: '/api/metrics/gallery-generator',
      headers: { 'content-type': 'application/json' },
      body: Buffer.from(JSON.stringify({ event: 'test', user: 'test-user' })),
      ctx: {},
      url: new URL('http://localhost/api/metrics/gallery-generator?foo=bar'), // Added fake URL
      query: { foo: 'bar' }, // Added fake query
      httpVersion: '',
      raw: '',
    };
    let responseCode = 0;
    let responseBody = '';
    const sock = {
      write: (data: string) => {
        if (data.includes('200')) responseCode = 200;
        responseBody += data;
      },
      end: () => {},
    } as unknown as Socket;
    await router.handle(req, sock);
    expect(responseCode).toBe(200);
    expect(responseBody).toContain('OK');
  });

  it('should return 404 for unknown metrics app', async () => {
    const req: Omit<IncomingRequest, 'ctx'> & { ctx: Record<string, unknown> } = {
      method: 'POST',
      path: '/api/metrics/unknown-app',
      headers: { 'content-type': 'application/json' },
      body: Buffer.from(JSON.stringify({ event: 'test' })),
      ctx: {},
      url: new URL('http://localhost/api/metrics/unknown-app'), // Added fake URL
      query: {}, // Added empty query
      httpVersion: '1.1', // Added HTTP version
      raw: '', // Added raw request string
    };
    let responseCode = 0;
    let responseBody = '';
    const sock = {
      write: (data: string) => {
        if (data.includes('404')) responseCode = 404;
        responseBody += data;
      },
      end: () => {},
    } as unknown as Socket;
    await router.handle(req, sock);
    expect(responseCode).toBe(404);
    expect(responseBody).toContain('Not Found');
  });
});
</file>

<file path="modules/file-streamer/fileService.test.ts">
import { FileService } from '../../../src/modules/file-streaming/fileService';
import * as fs from 'fs';
import { Socket } from 'net';
import { sendResponse } from '../../../src/entities/sendResponse';

jest.mock('fs');
jest.mock('../../../src/entities/sendResponse');

describe('FileService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('listFiles', () => {
    it('should list files when media directory exists', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.readdirSync as jest.Mock).mockReturnValue(['video.mp4', 'audio.mp3']);

      const result = FileService.listFiles();

      expect(result.files).toEqual(['video.mp4', 'audio.mp3']);
    });

    it("should return empty list if media directory doesn't exist", () => {
      (fs.existsSync as jest.Mock).mockReturnValue(false);

      const result = FileService.listFiles();

      expect(result.files).toEqual([]);
    });
  });

  describe('streamFile', () => {
    const fakeSocket = {
      write: jest.fn(),
      end: jest.fn(),
      on: jest.fn(),
      pipe: jest.fn(),
    } as unknown as Socket;

    it('should handle non-existing file gracefully', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(false);

      FileService.streamFile('nofile.mp4', undefined, fakeSocket);

      expect(sendResponse).toHaveBeenCalledWith(
        fakeSocket,
        404,
        expect.any(Object),
        expect.any(String),
      );
    });

    it('should handle invalid range requests', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });

      FileService.streamFile('video.mp4', 'bytes=2000-3000', fakeSocket);

      expect(sendResponse).toHaveBeenCalledWith(
        fakeSocket,
        416,
        expect.any(Object),
        expect.any(String),
      );
    });

    it('should start a stream for a valid file', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', undefined, fakeSocket);

      expect(sendResponse).toHaveBeenCalledWith(
        fakeSocket,
        206,
        expect.any(Object),
        expect.anything(),
      );
    });

    it('should handle file stream error', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });

      const mockStream = {
        pipe: jest.fn(),
        on: jest.fn((event, handler) => {
          if (event === 'error') {
            handler(new Error('Stream failed'));
          }
        }),
      };
      (fs.createReadStream as jest.Mock).mockReturnValue(mockStream);

      FileService.streamFile('video.mp4', undefined, fakeSocket);

      expect(sendResponse).toHaveBeenCalledWith(
        fakeSocket,
        500,
        expect.any(Object),
        expect.any(String),
      );
    });

    it('should stream partial content for valid small range', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', 'bytes=0-499', fakeSocket);

      expect(sendResponse).toHaveBeenCalledWith(
        fakeSocket,
        206,
        expect.any(Object),
        expect.anything(),
      );
    });

    it('should stream partial content for valid range bytes=0-499', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', 'bytes=0-499', fakeSocket);

      expect(sendResponse).toHaveBeenCalledWith(
        fakeSocket,
        206,
        expect.any(Object),
        expect.anything(),
      );
    });

    it('should handle range with no start (e.g., bytes=-500)', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', 'bytes=-500', fakeSocket);

      expect(sendResponse).toHaveBeenCalledWith(
        fakeSocket,
        206,
        expect.any(Object),
        expect.anything(),
      );
    });

    it('should handle range with no end (e.g., bytes=500-)', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', 'bytes=500-', fakeSocket);

      expect(sendResponse).toHaveBeenCalledWith(
        fakeSocket,
        206,
        expect.any(Object),
        expect.anything(),
      );
    });

    it('should return 416 for invalid range format (e.g., bytes=invalid)', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });

      FileService.streamFile('video.mp4', 'bytes=invalid', fakeSocket);

      expect(sendResponse).toHaveBeenCalledWith(
        fakeSocket,
        416,
        expect.any(Object),
        expect.any(String),
      );
    });
  });
});
</file>

<file path="modules/file-streamer/fileStreamingController.test.ts">
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-require-imports */
let fileStreamingController: any;
let fs: any;
let fsPromises: any;
let config: any;
import { IncomingRequest } from '../../../src/entities/http';
import { sendResponse } from '../../../src/entities/sendResponse';
import { Socket } from 'net';
import { Readable } from 'stream';
jest.mock('fs');
jest.mock('fs/promises');
jest.mock('../../../src/entities/sendResponse');

const fakeStream = new Readable({ read() {} }); // a real Readable stream

// Dynamically load controller after resetting modules and config
describe('fileStreamingController', () => {
  const fakeSocket = {
    write: jest.fn(),
    end: jest.fn(),
  } as unknown as Socket;

  beforeEach(() => {
    jest.resetModules();
    jest.clearAllMocks();
    // require fresh modules after reset
    fs = require('fs');
    fsPromises = require('fs/promises');
    config = require('../../../src/config/server.config').config;
    config.mediaDir = '/mocked/media';
    // mock fs methods
    fs.existsSync.mockReturnValue(true);
    fsPromises.readdir.mockResolvedValue(['video.mp4']);
    fsPromises.stat.mockResolvedValue({ size: 1000, isFile: () => true });
    fs.createReadStream.mockReturnValue(fakeStream);
    // load controller after mocks and config override
    fileStreamingController =
      require('../../../src/modules/file-streamer/fileStreamingController').fileStreamingController;
  });

  it('should respond with 400 if no file param on stream', async () => {
    const req = {
      url: new URL('http://localhost/stream'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    } as IncomingRequest;
    await fileStreamingController.handleStream(req, fakeSocket);
    expect(sendResponse).toHaveBeenCalledWith(
      fakeSocket,
      400,
      expect.any(Object),
      expect.any(String),
    );
  });

  it('should respond with 404 if file does not exist', async () => {
    // Simulate missing file by having stat reject
    fsPromises.stat.mockRejectedValueOnce(new Error('File not found'));

    const req = {
      url: new URL('http://localhost/stream?file=nonexistent.mp4'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: { file: 'nonexistent.mp4' },
    } as IncomingRequest;

    await fileStreamingController.handleStream(req, fakeSocket);
    expect(sendResponse).toHaveBeenCalledWith(
      fakeSocket,
      404,
      expect.any(Object),
      expect.any(String),
    );
  });

  it('should list files correctly', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/files'),
      method: 'GET',
      path: '/files',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };

    await fileStreamingController.listFiles(req, fakeSocket);

    expect(sendResponse).toHaveBeenCalledWith(
      fakeSocket,
      200,
      expect.any(Object),
      expect.any(String),
    );
  });

  it('should stream file if it exists', async () => {
    const req = {
      url: new URL('http://localhost/stream?file=video.mp4'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost', range: 'bytes=0-499' },
      raw: '',
      query: { file: 'video.mp4' },
    } as IncomingRequest;

    await fileStreamingController.handleStream(req, fakeSocket);

    expect(sendResponse).toHaveBeenCalledWith(
      fakeSocket,
      206,
      expect.any(Object),
      expect.anything(),
    );
    // also assert correct Content-Type header
    expect(fs.createReadStream).toHaveBeenCalledWith(expect.stringContaining('video.mp4'), {
      start: 0,
      end: 499,
    });
  });
});
</file>

<file path="utils/helpers.test.ts">
import { getMimeType } from '../../src/utils/helpers';

describe('Helpers - getMimeType', () => {
  it('should return correct MIME type for mp4', () => {
    expect(getMimeType('movie.mp4')).toBe('video/mp4');
  });

  it('should return correct MIME type for jpg', () => {
    expect(getMimeType('image.jpg')).toBe('image/jpeg');
  });

  it('should return default MIME type for unknown file extension', () => {
    expect(getMimeType('something.unknownext')).toBe('application/octet-stream');
  });

  it('should return default MIME type for file with no extension', () => {
    expect(getMimeType('README')).toBe('application/octet-stream');
  });
});
</file>

<file path="utils/logger.test.ts">
import { logger } from '../../src/utils/logger';

describe('Logger', () => {
  it('should log info messages', () => {
    const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
    logger.info('Hello World');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should log warning messages', () => {
    const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
    logger.warn('Watch out!');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should log error messages', () => {
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
    logger.error('This is bad!');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should conditionally log debug messages', () => {
    process.env.NODE_ENV = 'development';
    const consoleSpy = jest.spyOn(console, 'debug').mockImplementation();
    logger.debug('Debugging...');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
    // restore original NODE_ENV
    delete process.env.NODE_ENV;
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });
});
</file>

<file path="global.d.ts">
/// <reference types="jest-extended" />

export {};
</file>

<file path="setupJest.ts">
import 'jest-extended';

export const add = (a: number, b: number): number => {
  return a + b;
};

export const subtract = (a: number, b: number): number => {
  return a - b;
};
</file>

<file path="core/http_stress.test.ts">
import { createConnection } from 'net';
import { config } from '../../src/config/server.config'; // assuming your port config
import { HttpServer } from '../../src/core/server';

jest.setTimeout(20000); // Increase timeout for all tests in this file
config.bodyTimeoutMs = 10000; // Set body timeout to 10 seconds
config.headerTimeoutMs = 10000; // Set header timeout to 10 seconds
let server: HttpServer;

beforeAll(async () => {
  server = new HttpServer(config.port);
  server.start();
  // Wait briefly to ensure server is ready
  await new Promise((res) => setTimeout(res, 300));
});

afterEach(() => {
  jest.clearAllTimers();
});

afterAll(async () => {
  await server.stop();
  // Ensure all sockets are closed using the new public method
  server.destroySockets();
});

function sendRawRequest(payload: string | Buffer, expectClose: boolean = true): Promise<string> {
  return new Promise((resolve, reject) => {
    const client = createConnection({ port: config.port }, () => {
      client.write(payload);
    });

    let data = '';
    let timeout: NodeJS.Timeout | null = null;

    client.on('data', (chunk) => {
      data += chunk.toString();
    });

    client.on('end', () => {
      if (timeout) clearTimeout(timeout);
      resolve(data);
    });

    client.on('error', (err) => {
      if (timeout) clearTimeout(timeout);
      reject(err);
    });

    if (!expectClose) {
      timeout = setTimeout(() => client.end(), 3000); // manual timeout fallback
    }
  });
}

describe('üî• HTTP Server TCP Stress Tests', () => {
  it('handles simple GET properly', async () => {
    const response = await sendRawRequest('GET /files HTTP/1.1\r\nHost: localhost\r\n\r\n');
    expect(response).toMatch(/HTTP\/1\.1 200 OK/);
  });

  it('handles fragmented headers across TCP packets', async () => {
    const sock = createConnection({ port: config.port });

    sock.write('GET /files HT');
    await new Promise((r) => setTimeout(r, 50));
    sock.write('TP/1.1\r\nHo');
    await new Promise((r) => setTimeout(r, 50));
    sock.write('st: localhost\r\n\r\n');

    let response = '';
    sock.on('data', (chunk) => {
      response += chunk.toString();
    });

    const res = await new Promise<string>((resolve) => {
      sock.on('end', () => resolve(response));
    });

    expect(res).toMatch(/HTTP\/1\.1 200 OK/);
  });

  it('handles invalid request line (bad client)', async () => {
    const response = await sendRawRequest('BADREQUEST\r\nHost: localhost\r\n\r\n');
    expect(response).toMatch(/HTTP\/1.1 400 Bad Request/);
  });

  it('rejects massive headers flood', async () => {
    const massiveHeaders = Array(1200).fill('X-Flood: yes').join('\r\n');
    const request = `GET / HTTP/1.1\r\n${massiveHeaders}\r\n\r\n`;
    const response = await sendRawRequest(request);
    expect(response).toMatch(/HTTP\/1.1 400 Bad Request/);
  });

  it('rejects huge body POST (over limit)', async () => {
    const bigBody = 'A'.repeat(12 * 1024 * 1024); // 12MB
    const request = `POST / HTTP/1.1\r\nHost: localhost\r\nContent-Length: ${bigBody.length}\r\n\r\n${bigBody}`;
    const response = await sendRawRequest(request);
    expect(response).toMatch(/HTTP\/1.1 400 Bad Request/);
  });

  it('handles chunked upload streamed slowly', async () => {
    const sock = createConnection({ port: config.port });
    const parts = [
      'POST /upload HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n',
      '5\r\nHello\r\n',
      '6\r\n World\r\n',
      '0\r\n\r\n',
    ];

    for (const p of parts) {
      sock.write(p);
      await new Promise((r) => setTimeout(r, 100));
    }

    let response = '';
    sock.on('data', (chunk) => {
      response += chunk.toString();
    });

    const res = await new Promise<string>((resolve) => {
      sock.on('end', () => resolve(response));
    });

    expect(res).toMatch(/HTTP\/1\.1/);
    expect(res).not.toMatch(/400/);
  });

  // Add a test for header folding
  it('handles folded headers correctly', async () => {
    const foldedHeaderRequest = `GET / HTTP/1.1\r\nHost: localhost\r\nX-Folded: part1\r\n\tpart2\r\n\r\n`;
    const response = await sendRawRequest(foldedHeaderRequest);
    expect(response).toMatch(/HTTP\/1\.1 404 Not Found/);
  });

  it('supports HTTP/1.1 pipelined requests', async () => {
    const payload =
      'GET /files HTTP/1.1\r\nHost: localhost\r\n\r\n' +
      'GET /files HTTP/1.1\r\nHost: localhost\r\n\r\n';
    const response = await sendRawRequest(payload, false);
    const occurrences = (response.match(/HTTP\/1\.1/gi) || []).length;
    expect(occurrences).toBe(2);
  });
});
</file>

</files>
