This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
  pull_request_template.md
.husky/
  pre-commit
src/
  config/
    server.config.ts
  core/
    parser.ts
    router.ts
    server.ts
  entities/
    http.ts
    sendResponse.ts
  modules/
    file-streamer/
      fileService.ts
      fileStreamingController.ts
      index.ts
  routes/
    files.routes.ts
    index.ts
    stream.routes.ts
  utils/
    helpers.ts
    httpHelpers.ts
    logger.ts
    mimeTypes.ts
  main.ts
tests/
  core/
    parser.test.ts
    router.test.ts
  modules/
    file-streamer/
      fileService.test.ts
      fileStreamingController.test.ts
  utils/
    helpers.test.ts
    logger.test.ts
.gitignore
.prettierignore
.prettierrc
eslint.config.js
jest.config.js
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  lint-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Use your Node.js version (like 20.x or whatever you use)

      - name: Install dependencies
        run: npm install

      - name: Run Lint
        run: npm run lint

      - name: Type Check
        run: npm run type-check

      - name: Run Tests
        run: npm test
</file>

<file path=".github/pull_request_template.md">
# üìã Description

> Briefly describe what this Pull Request does.

Include any context necessary to understand the scope.  
Explain **why** the change is needed, and **what** was done.

---

## üõ† Changes Made

- [ ] Refactored modules for better scalability
- [ ] Improved HTTP request handling
- [ ] Added new utility/helper classes
- [ ] Updated or added tests
- [ ] Other (specify):

---

## ‚úÖ Testing

- [ ] Ran all unit tests successfully
- [ ] Manual validation (if applicable)
- [ ] Linted and type-checked cleanly
- [ ] Verified functionality locally

---

## üî• Risk Level

| Risk      | Reason                                                        |
| :-------- | :------------------------------------------------------------ |
| üü¢ Low    | Well-tested refactor, no breaking changes                     |
| üü† Medium | Introduces new module(s) or restructures key flows            |
| üî¥ High   | Impacts critical functionality (server, file streaming, etc.) |

---

## üì£ Notes for Reviewers

(Optional)  
Add any extra context, screenshots, or tips to help reviewers test faster.

---

## üéØ Related Issues / Tickets

(If connected to any GitHub Issues or Tasks)  
Example:

- Closes #15
- Related to #12

---

## üìÖ Pre-Merge Checklist

- [ ] Code is self-documented
- [ ] PR only contains the intended changes
- [ ] No commented-out, dead, or debug code
- [ ] Documentation updated (if needed)
- [ ] Conventional Commit Message used (e.g., `feat:`, `fix:`, `refactor:`)

---

## üìã Example PR Title Suggestions

| When                 | Example Title                                                   |
| :------------------- | :-------------------------------------------------------------- |
| Adding a new feature | `feat: add file streaming controller for central hub`           |
| Fixing a bug         | `fix: correct HTTP header parsing in core parser`               |
| Refactoring          | `refactor: standardize HTTP responses with sendResponse helper` |
| Maintenance          | `chore: add GitHub pull request template`                       |
</file>

<file path="src/routes/files.routes.ts">
// routes/files.routes.ts
import { router } from '../core/router';
import { fileStreamingController } from '../modules/file-streamer';

router.get('/files', fileStreamingController.listFiles);
</file>

<file path="src/routes/index.ts">
// routes/index.ts
import './stream.routes';
import './files.routes';

export {}; // side-effect imports run immediately
</file>

<file path="src/routes/stream.routes.ts">
// routes/stream.routes.ts
import { router } from '../core/router';
import { fileStreamingController } from '../modules/file-streamer';

router.get('/stream', fileStreamingController.handleStream);
</file>

<file path=".prettierignore">
dist/
node_modules/
coverage/
public/
</file>

<file path=".prettierrc">
{
    "semi": true,
    "singleQuote": true,
    "trailingComma": "all",
    "printWidth": 100,
    "tabWidth": 2,
    "endOfLine": "lf"
  }
</file>

<file path="src/entities/sendResponse.ts">
import { Socket } from 'net';
import { Readable } from 'stream';

const STATUS_TEXT: Record<number, string> = {
  200: 'OK',
  206: 'Partial Content',
  400: 'Bad Request',
  404: 'Not Found',
  405: 'Method Not Allowed',
  416: 'Range Not Satisfiable', // ‚Üê new
  500: 'Internal Server Error',
};

export function sendResponse(
  socket: Socket,
  status: number,
  headers: Record<string, string>,
  body?: string | Buffer | Readable,
): void {
  const head =
    `HTTP/1.1 ${status} ${STATUS_TEXT[status] ?? ''}\r\n` +
    Object.entries(headers)
      .map(([k, v]) => `${k}: ${v}`)
      .join('\r\n') +
    '\r\n\r\n';

  socket.write(head);

  if (!body) {
    socket.end();
    return;
  }

  if (body instanceof Readable) {
    body.pipe(socket);
    body.once('error', () => socket.end());
    body.once('end', () => socket.end());
  } else {
    socket.write(body);
    socket.end();
  }
}
</file>

<file path="src/modules/file-streamer/fileStreamingController.ts">
import { Socket } from 'net';
import { sendResponse } from '../../entities/sendResponse';
import { IncomingRequest } from '../../entities/http';
import { FileService } from './fileService';
import { getHeader, getQuery } from '../../utils/httpHelpers';
import { config } from '../../config/server.config';
import { logger } from '../../utils/logger';
import { getMimeType } from '../../utils/helpers';
import { Readable } from 'stream';
import { createGzip, createBrotliCompress } from 'zlib';

const fileSvc = new FileService(config.goonDir);

export const fileStreamingController = {
  /** GET /files ‚Äì returns JSON list of filenames */
  async listFiles(req: IncomingRequest, sock: Socket) {
    try {
      const files = await fileSvc.listFiles();
      sendResponse(sock, 200, { 'Content-Type': 'application/json' }, JSON.stringify(files));
    } catch (err) {
      logger.error(`listFiles: ${(err as Error).message}`);
      sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, 'Server error');
    }
  },

  /** GET /stream?file=video.mp4 ‚Äì streams file (supports Range) */
  async handleStream(req: IncomingRequest, sock: Socket) {
    logger.info(
      `[handleStream] url=${req.url} path=${req.path} query=${JSON.stringify(req.query)}`,
    );
    const fileName = getQuery(req, 'file');
    if (!fileName) {
      sendResponse(
        sock,
        400,
        { 'Content-Type': 'text/plain' },
        'Missing required "file" query parameter.',
      );
      return;
    }

    try {
      const rangeHdr = getHeader(req, 'range'); // e.g. "bytes=0-1023"
      let stream: Readable;
      const fileStat = await fileSvc.stat(fileName);
      const size = fileStat.size;
      if (rangeHdr) {
        // Parse Range header: bytes=START-END, bytes=START-, bytes=-END
        const m = /bytes=(\d*)-(\d*)/.exec(rangeHdr);
        if (!m) {
          sendResponse(sock, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          sock.end();
          return;
        }
        const startStr = m[1];
        const endStr = m[2];
        let start: number;
        let end: number;
        if (startStr) {
          start = parseInt(startStr, 10);
          end = endStr ? parseInt(endStr, 10) : size - 1;
        } else {
          // suffix range
          const suffix = parseInt(endStr, 10);
          start = size - suffix;
          end = size - 1;
        }
        if (start > end || start < 0 || end >= size) {
          sendResponse(sock, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          sock.end();
          return;
        }
        stream = await fileSvc.readFile(fileName, { start, end });
        const len = end - start + 1;
        sendResponse(
          sock,
          206,
          {
            'Content-Type': getMimeType(fileName) || 'application/octet-stream',
            'Accept-Ranges': 'bytes',
            'Content-Range': `bytes ${start}-${end}/${size}`,
            'Content-Length': String(len),
          },
          stream,
        );
      } else {
        stream = await fileSvc.readFile(fileName);
        const mimeType = getMimeType(fileName);
        const acceptEnc = getHeader(req, 'accept-encoding') || '';
        if (acceptEnc.includes('gzip')) {
          const brotliStream = (stream as Readable).pipe(createGzip());
          sendResponse(
            sock,
            200,
            {
              'Content-Type': mimeType,
              'Content-Encoding': 'gzip',
              Vary: 'Accept-Encoding',
            },
            brotliStream,
          );
        } else if (acceptEnc.includes('br')) {
          const gzipStream = (stream as Readable).pipe(createBrotliCompress());
          sendResponse(
            sock,
            200,
            {
              'Content-Type': mimeType,
              'Content-Encoding': 'br',
              Vary: 'Accept-Encoding',
            },
            gzipStream,
          );
        } else {
          sendResponse(
            sock,
            200,
            { 'Content-Type': mimeType, 'Content-Length': String(size) },
            stream,
          );
        }
      }
    } catch (err) {
      logger.error(`[handleStream] fileName=${fileName}, error=${(err as Error).message}`);
      sendResponse(sock, 404, { 'Content-Type': 'text/plain' }, `File "${fileName}" not found.`);
    }
  },
};
</file>

<file path="src/utils/helpers.ts">
import { extname } from 'path';
import { mimeTypes } from './mimeTypes';

export function getMimeType(fileName: string): string {
  const ext = extname(fileName).toLowerCase();
  return mimeTypes[ext] || 'application/octet-stream';
}
</file>

<file path="src/utils/httpHelpers.ts">
// Simple header accessor that falls back to legacy Record<string,string>
import { IncomingRequest } from '../entities/http';

/**
 * Case-insensitive lookup that handles multi-value headers.
 * @param req - The incoming request object.
 * @param name - The name of the header to retrieve.
 * @returns The value of the header, or undefined if not found.
 * @example
 * const contentType = getHeader(req, 'Content-Type');
 * const userAgent = getHeader(req, 'User-Agent');
 * const customHeader = getHeader(req, 'X-Custom-Header');
 */
export function getHeader(req: IncomingRequest, name: string): string | undefined {
  const key = name.toLowerCase();
  if (req.headersMap && req.headersMap.has(key)) {
    return req.headersMap.get(key)![0]; // first value
  }
  return req.headers?.[key];
}

/** Case-sensitive query lookup that falls back to searchParams */
export function getQuery(req: IncomingRequest, key: string): string | undefined {
  if (req.invalid || !req.query || !req.url) return undefined;

  // ‚úÖ look in the parser-built map first
  const direct = req.query?.[key];
  if (direct !== undefined) return direct;

  // fallback (rare) ‚Äì parse from URL
  return req.url.searchParams.get(key) ?? undefined;
}
</file>

<file path="src/utils/logger.ts">
// src/utils/logger.ts

type LogLevel = 'info' | 'warn' | 'error' | 'debug';

class Logger {
  private getTimestamp(): string {
    return new Date().toISOString();
  }

  private formatMessage(level: LogLevel, message: string): string {
    return `[${this.getTimestamp()}] [${level.toUpperCase()}]: ${message}`;
  }

  info(message: string): void {
    console.log(this.formatMessage('info', message));
  }

  warn(message: string): void {
    console.warn(this.formatMessage('warn', message));
  }

  error(message: string): void {
    console.error(this.formatMessage('error', message));
  }

  debug(message: string): void {
    if (process.env.NODE_ENV === 'development') {
      console.debug(this.formatMessage('debug', message));
    }
  }
}

// Export a singleton instance
export const logger = new Logger();
</file>

<file path="src/utils/mimeTypes.ts">
export const mimeTypes: Record<string, string> = {
  '.html': 'text/html',
  '.htm': 'text/html',
  '.js': 'application/javascript',
  '.json': 'application/json',
  '.css': 'text/css',
  '.txt': 'text/plain',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.png': 'image/png',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.mp3': 'audio/mpeg',
  '.mp4': 'video/mp4',
  '.webm': 'video/webm',
  '.ogg': 'audio/ogg',
  '.pdf': 'application/pdf',
  '.zip': 'application/zip',
  '.tar': 'application/x-tar',
};
</file>

<file path="tests/utils/helpers.test.ts">
import { getMimeType } from '../../src/utils/helpers';

describe('Helpers - getMimeType', () => {
  it('should return correct MIME type for mp4', () => {
    expect(getMimeType('movie.mp4')).toBe('video/mp4');
  });

  it('should return correct MIME type for jpg', () => {
    expect(getMimeType('image.jpg')).toBe('image/jpeg');
  });

  it('should return default MIME type for unknown file extension', () => {
    expect(getMimeType('something.unknownext')).toBe('application/octet-stream');
  });

  it('should return default MIME type for file with no extension', () => {
    expect(getMimeType('README')).toBe('application/octet-stream');
  });
});
</file>

<file path="tests/utils/logger.test.ts">
import { logger } from '../../src/utils/logger';

describe('Logger', () => {
  it('should log info messages', () => {
    const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
    logger.info('Hello World');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should log warning messages', () => {
    const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
    logger.warn('Watch out!');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should log error messages', () => {
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
    logger.error('This is bad!');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });

  it('should conditionally log debug messages', () => {
    process.env.NODE_ENV = 'development';
    const consoleSpy = jest.spyOn(console, 'debug').mockImplementation();
    logger.debug('Debugging...');
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });
});
</file>

<file path=".gitignore">
# Node.js dependencies
node_modules/

# Output directories
dist/
build/

# Logs
*.log

# System-specific files
.DS_Store
Thumbs.db

# Environment variables
.env
.env.*

# Editor folders
.vscode/
.idea/

# Coverage reports (future testing)
coverage/

# Temporary files
temp/
*.tmp
*.swp

# OS Trash
*.Trash-*

# Lock files
yarn.lock
package-lock.json
pnpm-lock.yaml

# Miscellaneous
.eslintcache
*.config

# Public files
public/
</file>

<file path="jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ["**/tests/**/*.test.ts"],  // <--- IMPORTANT
  moduleFileExtensions: ["ts", "js", "json", "node"],
  modulePathIgnorePatterns: ["<rootDir>/dist/"],
  transform: {
    "^.+\\.ts$": "ts-jest",
  },
  globals: {
    "ts-jest": {
      isolatedModules: true
    }
  }
};
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "outDir": "dist",
      "rootDir": ".",
      "strict": true,
      "esModuleInterop": true,
      "forceConsistentCasingInFileNames": true,
      "skipLibCheck": true
    }
  }
</file>

<file path=".husky/pre-commit">
#!/bin/sh

npm run lint
npm run type-check
npm run test
</file>

<file path="tests/modules/file-streamer/fileService.test.ts">
import { FileService } from '../../../src/modules/file-streamer/fileService';
import * as fs from 'fs';
import { Socket } from 'net';

jest.mock('fs');

describe('FileService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('listFiles', () => {
    it('should list files when media directory exists', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.readdirSync as jest.Mock).mockReturnValue(['video.mp4', 'audio.mp3']);

      const result = FileService.listFiles();

      expect(result.files).toEqual(['video.mp4', 'audio.mp3']);
    });

    it("should return empty list if media directory doesn't exist", () => {
      (fs.existsSync as jest.Mock).mockReturnValue(false);

      const result = FileService.listFiles();

      expect(result.files).toEqual([]);
    });
  });

  describe('streamFile', () => {
    const fakeSocket = {
      write: jest.fn(),
      end: jest.fn(),
      on: jest.fn(),
      pipe: jest.fn(),
    } as unknown as Socket;

    it('should handle non-existing file gracefully', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(false);

      FileService.streamFile('nofile.mp4', undefined, fakeSocket);

      expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('404 Not Found'));
      expect(fakeSocket.end).toHaveBeenCalled();
    });

    it('should handle invalid range requests', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });

      FileService.streamFile('video.mp4', 'bytes=2000-3000', fakeSocket);

      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('416 Range Not Satisfiable'),
      );
      expect(fakeSocket.end).toHaveBeenCalled();
    });

    it('should start a stream for a valid file', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', undefined, fakeSocket);

      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });

    it('should handle file stream error', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });

      const mockStream = {
        pipe: jest.fn(),
        on: jest.fn((event, handler) => {
          if (event === 'error') {
            handler(new Error('Stream failed'));
          }
        }),
      };
      (fs.createReadStream as jest.Mock).mockReturnValue(mockStream);

      FileService.streamFile('video.mp4', undefined, fakeSocket);

      expect(fakeSocket.end).toHaveBeenCalled();
    });

    it('should stream partial content for valid small range', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', 'bytes=0-499', fakeSocket);

      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });

    it('should stream partial content for valid range bytes=0-499', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', 'bytes=0-499', fakeSocket);

      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });

    it('should handle range with no start (e.g., bytes=-500)', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', 'bytes=-500', fakeSocket);

      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });

    it('should handle range with no end (e.g., bytes=500-)', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn(),
      });

      FileService.streamFile('video.mp4', 'bytes=500-', fakeSocket);

      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('HTTP/1.1 206 Partial Content'),
      );
    });

    it('should return 416 for invalid range format (e.g., bytes=invalid)', () => {
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1000 });

      FileService.streamFile('video.mp4', 'bytes=invalid', fakeSocket);

      expect(fakeSocket.write).toHaveBeenCalledWith(
        expect.stringContaining('416 Range Not Satisfiable'),
      );
      expect(fakeSocket.end).toHaveBeenCalled();
    });
  });
});
</file>

<file path="eslint.config.js">
const js = require('@eslint/js');
const tseslint = require('typescript-eslint');
const prettier = require('eslint-plugin-prettier');
const markdown = require('eslint-plugin-markdown');

module.exports = [
  js.configs.recommended,
  ...tseslint.configs.recommended,
  {
    ignores: ['dist/', 'node_modules/', 'coverage/', 'public/'],
    plugins: {
      prettier: prettier,
      markdown: markdown,
    },
    rules: {
      'prettier/prettier': 'error',
    },
  },
  {
    files: ['**/*.md'],
    plugins: {
      markdown: markdown,
    },
    processor: 'markdown/markdown',
  },
];
</file>

<file path="src/config/server.config.ts">
import dotenv from 'dotenv';
import { join } from 'path';
import { logger } from '../utils/logger';

// Load environment variables from .env file
dotenv.config();

export const config = {
  port: process.env.PORT ? parseInt(process.env.PORT, 10) : 8080,
  publicDir: process.env.PUBLIC_DIR
    ? join(process.cwd(), process.env.PUBLIC_DIR)
    : join(process.cwd(), 'public'),
  mediaDir: process.env.MEDIA_DIR
    ? join(process.cwd(), process.env.MEDIA_DIR)
    : join(process.cwd(), 'media'),
  goonDir: '/Users/toluadegbehingbe/Library/Mobile Documents/com~apple~CloudDocs/goon/temp',
};

logger.info(`Server configuration:`);
logger.info(`- Port: ${config.port}`);
logger.info(`- Public Directory: ${config.publicDir}`);
logger.info(`- Media Directory: ${config.goonDir}`);
</file>

<file path="src/entities/http.ts">
export interface IncomingRequest {
  url: URL; // canonical URL (always present)
  path: string; // == url.pathname
  query: Record<string, string>; // decoded single-value map
  httpVersion: string; // e.g. "HTTP/1.1"

  method: string;
  headers: Record<string, string>;
  headersMap?: Map<string, string[]>;
  body?: Buffer;
  raw: string;
  ctx?: Record<string, unknown>;
  invalid?: boolean;
}
</file>

<file path="src/core/parser.ts">
import { IncomingRequest } from '../entities/http';
import { URL } from 'url';

const ALLOWED_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'] as const;
const MAX_HEADERS = 1000;

// helper for duplicate headers
function addHeader(map: Map<string, string[]>, key: string, value: string) {
  const k = key.toLowerCase();
  const list = map.get(k) ?? [];
  list.push(value);
  map.set(k, list);
}

export const parser = {
  parse(raw: string): IncomingRequest {
    const dummyUrl = new URL('http://placeholder/');
    const earlyReturn = (): IncomingRequest => ({
      url: dummyUrl,
      path: '',
      query: {},
      httpVersion: '',
      method: '',
      headers: {},
      headersMap: new Map(),
      raw,
      ctx: {},
      invalid: true,
    });

    /* -------- empty buffer guard -------- */
    if (raw.length === 0) return earlyReturn();

    const [head = '', bodyString = ''] = raw.split('\r\n\r\n');
    const lines = head.split('\r\n');

    /* -------- request-line split -------- */
    const [requestLine, ...headerLines] = lines;
    const parts = requestLine.split(' ');
    if (parts.length < 3) return earlyReturn();

    const [method, fullPath, httpVersion] = parts;
    let invalid =
      !ALLOWED_METHODS.includes(method as (typeof ALLOWED_METHODS)[number]) ||
      !fullPath.startsWith('/') ||
      !httpVersion.startsWith('HTTP/');

    /* -------- URL + query -------- */
    const url = new URL(fullPath, 'http://placeholder');
    const query: Record<string, string> = {};
    url.searchParams.forEach((v, k) => (query[k] = v));

    /* -------- headers -------- */
    const headers: Record<string, string> = {};
    const headersMap = new Map<string, string[]>();

    if (headerLines.length > MAX_HEADERS) invalid = true;

    for (const line of headerLines) {
      const idx = line.indexOf(':');
      if (idx === -1) {
        invalid = true;
        continue;
      }
      const key = line.slice(0, idx).trim();
      const value = line.slice(idx + 1).trim();
      headers[key.toLowerCase()] = value;
      addHeader(headersMap, key, value);
    }

    const body = bodyString ? Buffer.from(bodyString, 'utf-8') : undefined;

    return {
      url,
      path: url.pathname,
      query,
      httpVersion,
      method,
      headers,
      headersMap,
      body,
      raw,
      ctx: {},
      invalid,
    };
  },
};
</file>

<file path="src/core/router.ts">
// src/core/router.ts
import { Socket } from 'net';
import { IncomingRequest } from '../entities/http';
import { sendResponse } from '../entities/sendResponse';
import { logger } from '../utils/logger';

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Types ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

export type Handler = (req: IncomingRequest, sock: Socket) => Promise<void> | void;
export type Middleware = (
  req: IncomingRequest,
  sock: Socket,
  next: () => Promise<void>,
) => Promise<void> | void;

interface Route {
  method: string; // 'GET' | 'POST' | 'ANY'
  regex: RegExp; // compiled path matcher
  keys: string[]; // param names (for :id stuff)
  handler: Handler;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Router implementation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

class Router {
  private middlewares: Middleware[] = [];
  private routes: Route[] = [];

  /* ---------- Middleware ---------- */
  use(mw: Middleware) {
    this.middlewares.push(mw);
  }

  /* ---------- Route registration helpers ---------- */
  add(method: string, path: string, handler: Handler) {
    const { regex, keys } = compilePath(path);
    this.routes.push({ method: method.toUpperCase(), regex, keys, handler });
  }
  get(path: string, h: Handler) {
    this.add('GET', path, h);
  }
  post(path: string, h: Handler) {
    this.add('POST', path, h);
  }
  put(path: string, h: Handler) {
    this.add('PUT', path, h);
  }
  del(path: string, h: Handler) {
    this.add('DELETE', path, h);
  }
  any(path: string, h: Handler) {
    this.add('ANY', path, h);
  }

  /* ---------- Main entry ---------- */
  async handle(req: IncomingRequest, sock: Socket): Promise<void> {
    if (!req.path || typeof req.path !== 'string') {
      sendResponse(sock, 400, { 'Content-Type': 'text/plain' }, 'Bad Request');
      return;
    }
    logger.info(`router saw ${req.method} ${req.path}`);
    // 1. run middleware chain
    let i = 0;
    const run = async (): Promise<void> => {
      if (i < this.middlewares.length) {
        const mw = this.middlewares[i++];
        await mw(req, sock, run);
      }
    };
    await run();

    // 2. route lookup
    const matching = this.routes.filter((r) => r.regex.test(req.path));
    const route =
      matching.find((r) => r.method === req.method) ?? matching.find((r) => r.method === 'ANY');

    if (!route) {
      // Distinguish 404 vs 405
      if (matching.length) {
        sendResponse(
          sock,
          405,
          { Allow: matching.map((r) => r.method).join(', ') },
          'Method Not Allowed',
        );
      } else {
        sendResponse(sock, 404, { 'Content-Type': 'text/plain' }, 'Not Found');
      }
      return;
    }

    // 3. pull params (/:id etc.) ‚Üí req.ctx.params
    const match = route.regex.exec(req.path)!;
    const params: Record<string, string> = {};
    route.keys.forEach((k, idx) => {
      params[k] = decodeURIComponent(match[idx + 1]);
    });
    (req.ctx ??= {}).params = params;

    // 4. invoke handler
    try {
      await route.handler(req, sock);
    } catch (err) {
      logger.error(`Handler error: ${(err as Error).message}`);
      sendResponse(sock, 500, { 'Content-Type': 'text/plain' }, '500 Server Error');
    }
  }
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Path pattern compiler ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   /files/:name  ->  ^/files/([^/]+)$           keys=['name']
   /api/*        ->  ^/api/(.*)$                keys=['*']
------------------------------------------------------------------------ */
function compilePath(pattern: string): { regex: RegExp; keys: string[] } {
  const keys: string[] = [];
  const regexSrc = pattern
    .replace(/\/:(\w+)/g, (_, k) => {
      keys.push(k);
      return '/([^/]+)';
    })
    .replace(/\*/g, () => {
      keys.push('*');
      return '(.*)';
    });
  return { regex: new RegExp(`^${regexSrc}$`), keys };
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Exports ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

export const router = new Router();
export default router; // so `import router` also works
</file>

<file path="src/modules/file-streamer/index.ts">
export { FileService } from './fileService';
export { fileStreamingController } from './fileStreamingController';
</file>

<file path="src/main.ts">
// main.ts
import './routes';
import { HttpServer } from './core/server';
import { config } from './config/server.config';
import { logger } from './utils/logger';
logger.info('routes loaded');

const server = new HttpServer(config.port);
server.start();
</file>

<file path="tests/core/router.test.ts">
import { router } from '../../src/core/router';
import { IncomingRequest } from '../../src/entities/http';
import { Socket } from 'net';

describe('Router', () => {
  const fakeSocket = {
    write: jest.fn(),
    end: jest.fn(),
  } as unknown as Socket;

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return 404 for unknown route', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/doesnotexist'),
      method: 'GET',
      path: '/doesnotexist',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };

    await router.handle(req, fakeSocket);

    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('404 Not Found'));
  });

  it('should handle a valid /files GET request', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/files'),
      method: 'GET',
      path: '/files',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };

    await router.handle(req, fakeSocket);

    expect(fakeSocket.write).toHaveBeenCalled(); // Should at least write something
  });

  it('should return 404 for wrong method', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/files'),
      method: 'POST', // Should be GET
      path: '/files',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };

    await router.handle(req, fakeSocket);

    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('404 Not Found'));
  });

  it('should handle missing path safely', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/'),
      method: 'GET',
      path: undefined as unknown as string, // force a bad input
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };

    await router.handle(req, fakeSocket);

    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('400 Bad Request'));
  });

  it('should match dynamic route /files/:filename', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/files/testfile.txt'),
      method: 'GET',
      path: '/files/testfile.txt',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };

    await router.handle(req, fakeSocket);

    expect(fakeSocket.write).toHaveBeenCalled(); // we should attempt to serve file
  });

  it('should return 500 if handler throws', async () => {
    router.get('/error', async () => {
      throw new Error('fail');
    });
    const validReq: IncomingRequest = {
      url: new URL('http://localhost/error'),
      method: 'GET',
      path: '/error',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };
    const req = { ...validReq, path: '/error' };

    await router.handle(req, fakeSocket);

    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('500 Server Error'));
  });
});
</file>

<file path="src/core/server.ts">
import { createServer, Socket } from 'net';
import { parser } from './parser';
import { router } from './router';
import { logger } from '../utils/logger';
import { sendResponse } from '../entities/sendResponse';

export class HttpServer {
  private server = createServer();
  private readonly connections = new Set<Socket>();

  constructor(private port: number) {
    this.setupServer();
  }

  private setupServer() {
    this.server.on('connection', (socket: Socket) => {
      this.connections.add(socket);
      const buffer: Buffer[] = [];

      socket.once('close', () => this.connections.delete(socket));
      logger.info('New connection established.');
      socket.on('data', async (chunk: Buffer) => {
        buffer.push(chunk);
        const full = Buffer.concat(buffer);

        // wait until we have all headers
        if (!full.includes('\r\n\r\n')) return;

        try {
          const request = parser.parse(full.toString());
          await router.handle(request, socket);
        } catch (err) {
          logger.error(`Failed request: ${(err as Error).message}`);
          sendResponse(socket, 400, { 'Content-Type': 'text/plain' }, 'Bad Request');
        }
        buffer.length = 0; // reset for next
      });

      socket.on('error', (err) => {
        logger.error(`Socket error: ${err.message}`);
      });
    });

    this.server.on('error', (err: NodeJS.ErrnoException) => {
      if (err.code === 'EADDRINUSE') {
        this.port += 1; // try the next port
        logger.warn(`Port busy, retrying on ${this.port}`);
        this.server.listen(this.port);
      } else {
        logger.error(`Server error: ${err.message}`);
      }
    });
  }

  /**
   * Gracefully shuts down the server and every open TCP socket.
   */
  public async stop(): Promise<void> {
    logger.info('üõë  Shutting down HTTP server');
    for (const sock of this.connections) sock.destroy();
    await new Promise<void>((resolve, reject) =>
      this.server.close((err) => (err ? reject(err) : resolve())),
    );
  }

  public start() {
    this.server.listen(this.port, () => {
      logger.info(`üöÄ Server running at port ${this.port}`);
    });

    // graceful shutdown on Ctrl-C / kill
    ['SIGINT', 'SIGTERM'].forEach((sig) =>
      process.on(sig as NodeJS.Signals, () => {
        this.stop()
          .then(() => process.exit(0))
          .catch(() => process.exit(1));
      }),
    );

    // src/core/server.ts  ‚Äì inside start() after existing SIGINT/SIGTERM hooks
    ['SIGUSR2'].forEach((sig) =>
      process.once(sig as NodeJS.Signals, () => {
        this.stop().then(() => process.kill(process.pid, sig));
      }),
    );
  }
}
</file>

<file path="tests/core/parser.test.ts">
import { parser } from '../../src/core/parser';

describe('HTTP Parser', () => {
  it('should parse a simple GET request', () => {
    const raw = 'GET /hello HTTP/1.1\r\nHost: localhost\r\nUser-Agent: test\r\n\r\n';
    const parsed = parser.parse(raw);

    expect(parsed.method).toBe('GET');
    expect(parsed.path).toBe('/hello');
    expect(parsed.httpVersion).toBe('HTTP/1.1');
    expect(parsed.headers.host).toBe('localhost');
    expect(parsed.headers['user-agent']).toBe('test');
  });

  it('should handle missing headers gracefully', () => {
    const raw = 'POST /upload HTTP/1.1\r\n\r\n';
    const parsed = parser.parse(raw);

    expect(parsed.method).toBe('POST');
    expect(parsed.path).toBe('/upload');
    expect(parsed.headers).toEqual({});
  });

  it('should not crash on completely malformed request', () => {
    const raw = 'INVALID REQUEST';
    const parsed = parser.parse(raw);

    expect(parsed.invalid).toBe(true);
    expect(parsed.method).toBeFalsy();
    expect(parsed.path).toBeFalsy();
  });

  it('should parse url.pathname and headersMap correctly', () => {
    const raw = 'GET /hello HTTP/1.1\r\nHost: localhost\r\nUser-Agent: test\r\n\r\n';
    const parsed = parser.parse(raw);

    expect(parsed.url?.pathname).toBe('/hello');
    expect(parsed.headersMap?.get('host')).toEqual(['localhost']);
  });

  it('exposes url, path, and query consistently', () => {
    const raw = 'GET /stream?file=test.mp4 HTTP/1.1\r\nHost: x\r\n\r\n';
    const r = parser.parse(raw);
    expect(r.url.pathname).toBe('/stream');
    expect(r.path).toBe('/stream');
    expect(r.query).toEqual({ file: 'test.mp4' });
  });

  it('includes httpVersion', () => {
    const raw = 'GET /test HTTP/1.1\r\nHost: x\r\n\r\n';
    const r = parser.parse(raw);
    expect(r.httpVersion).toBe('HTTP/1.1');
  });

  it('should handle completely empty request', () => {
    const raw = '';
    const parsed = parser.parse(raw);

    expect(parsed.invalid).toBe(true);
    expect(parsed.method).toBeFalsy();
    expect(parsed.path).toBeFalsy();
    expect(parsed.headers).toEqual({});
  });

  it('should correctly parse multiple query parameters', () => {
    const raw = 'GET /search?q=nodejs&sort=desc HTTP/1.1\r\nHost: localhost\r\n\r\n';
    const parsed = parser.parse(raw);

    expect(parsed.method).toBe('GET');
    expect(parsed.path).toBe('/search');
    expect(parsed.query).toEqual({ q: 'nodejs', sort: 'desc' });
  });

  it('should handle duplicated headers gracefully', () => {
    const raw = `GET / HTTP/1.1\r\nHost: localhost\r\nCookie: a=1\r\nCookie: b=2\r\n\r\n`;
    const parsed = parser.parse(raw);

    expect(parsed.headers.host).toBe('localhost');
    expect(parsed.headers['cookie']).toBe('b=2'); // Note: last wins in simple parsing
    expect(parsed.headersMap?.get('cookie')).toEqual(['a=1', 'b=2']);
  });
});
</file>

<file path="tests/modules/file-streamer/fileStreamingController.test.ts">
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-require-imports */
let fileStreamingController: any;
let fs: any;
let fsPromises: any;
let config: any;
import { IncomingRequest } from '../../../src/entities/http';
import { Socket } from 'net';
import { Readable } from 'stream';
jest.mock('fs');
jest.mock('fs/promises');

const fakeStream = new Readable({ read() {} }); // a real Readable stream

// Dynamically load controller after resetting modules and config
describe('fileStreamingController', () => {
  const fakeSocket = {
    write: jest.fn(),
    end: jest.fn(),
  } as unknown as Socket;

  beforeEach(() => {
    jest.resetModules();
    jest.clearAllMocks();
    // require fresh modules after reset
    fs = require('fs');
    fsPromises = require('fs/promises');
    config = require('../../../src/config/server.config').config;
    config.mediaDir = '/mocked/media';
    // mock fs methods
    fs.existsSync.mockReturnValue(true);
    fsPromises.readdir.mockResolvedValue(['video.mp4']);
    fsPromises.stat.mockResolvedValue({ size: 1000, isFile: () => true });
    fs.createReadStream.mockReturnValue(fakeStream);
    // load controller after mocks and config override
    fileStreamingController =
      require('../../../src/modules/file-streamer/fileStreamingController').fileStreamingController;
  });

  it('should respond with 400 if no file param on stream', async () => {
    const req = {
      url: new URL('http://localhost/stream'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    } as IncomingRequest;
    await fileStreamingController.handleStream(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(
      expect.stringContaining('Missing required "file"'),
    );
  });

  it('should respond with 404 if file does not exist', async () => {
    fs.existsSync.mockReturnValue(false);
    const req = {
      url: new URL('http://localhost/stream?file=nonexistent.mp4'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    } as IncomingRequest;
    await fileStreamingController.handleStream(req, fakeSocket);
    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('not found'));
  });

  it('should list files correctly', async () => {
    const req: IncomingRequest = {
      url: new URL('http://localhost/files'),
      method: 'GET',
      path: '/files',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost' },
      raw: '',
      query: {},
    };

    await fileStreamingController.listFiles(req, fakeSocket);

    expect(fakeSocket.write).toHaveBeenCalledWith(expect.stringContaining('HTTP/1.1 200 OK'));
  });

  it('should stream file if it exists', async () => {
    const req = {
      url: new URL('http://localhost/stream?file=video.mp4'),
      method: 'GET',
      path: '/stream',
      httpVersion: 'HTTP/1.1',
      headers: { host: 'localhost', range: 'bytes=0-499' },
      raw: '',
      query: { file: 'video.mp4' },
    } as IncomingRequest;

    await fileStreamingController.handleStream(req, fakeSocket);

    expect(fakeSocket.write).toHaveBeenCalledWith(
      expect.stringContaining('HTTP/1.1 206 Partial Content'),
    );
    expect(fs.createReadStream).toHaveBeenCalledWith(expect.stringContaining('video.mp4'), {
      start: 0,
      end: 499,
    });
  });
});
</file>

<file path="src/modules/file-streamer/fileService.ts">
// file-streamer/fileService.ts
import {
  existsSync,
  createReadStream,
  statSync,
  createWriteStream,
  readdirSync, // ‚Üê added for legacy tests
} from 'fs';
import { stat, readdir, mkdir } from 'fs/promises';
import { resolve, join } from 'path';
import { Readable } from 'stream';
import { Socket } from 'net';
import { config } from '../../config/server.config';
import { getMimeType } from '../../utils/helpers';
import { sendResponse } from '../../entities/sendResponse';

export class FileService {
  constructor(private readonly rootDir: string) {}

  private resolveSafe(relPath: string): string {
    const abs = resolve(this.rootDir, relPath);
    if (!abs.startsWith(this.rootDir)) throw new Error('Path traversal attempt');
    return abs;
  }

  /* ---------- modern async API ---------- */

  async listFiles(relDir = '.'): Promise<string[]> {
    return await readdir(this.resolveSafe(relDir));
  }

  async stat(relPath: string) {
    return await stat(this.resolveSafe(relPath));
  }

  async readFile(relPath: string, range?: { start: number; end: number }): Promise<Readable> {
    const abs = this.resolveSafe(relPath);
    return createReadStream(abs, range);
  }

  async saveFile(relPath: string, data: AsyncIterable<Buffer>): Promise<void> {
    const abs = this.resolveSafe(relPath);
    await mkdir(resolve(abs, '..'), { recursive: true });
    const ws = createWriteStream(abs);
    for await (const chunk of data) ws.write(chunk);
    await new Promise<void>((res, rej) => {
      ws.end(res);
      ws.on('error', rej);
    });
  }

  /* ---------- legacy static helpers (keep old tests green) ---------- */

  static listFiles(): { files: string[] } {
    const dir = config.goonDir;
    if (!existsSync(dir)) return { files: [] };
    return { files: readdirSync(dir) };
  }

  static streamFile(filename: string, rangeHeader: string | undefined, socket: Socket): void {
    //const abs = join(config.mediaDir, filename);
    const abs = resolve(config.goonDir, filename);

    if (!existsSync(abs)) {
      sendResponse(socket, 404, { 'Content-Type': 'text/plain' }, '404 Not Found');
      socket.end();
      return;
    }

    const stats = statSync(abs);
    const size = stats.size;

    const start = 0;
    const end = size - 1;

    if (rangeHeader) {
      // Matches bytes=START-END, bytes=START-, bytes=-END
      const m = /bytes=(\d*)-(\d*)/.exec(rangeHeader);

      if (m) {
        const startStr = m[1];
        const endStr = m[2];
        let start: number | undefined;
        let end: number | undefined;

        if (startStr && endStr) {
          // bytes=START-END
          start = parseInt(startStr, 10);
          end = parseInt(endStr, 10);
        } else if (startStr) {
          // bytes=START-
          start = parseInt(startStr, 10);
          end = size - 1;
        } else if (endStr) {
          // bytes=-END
          start = size - parseInt(endStr, 10);
          end = size - 1;
        }

        if (start === undefined || end === undefined || start > end || start >= size) {
          sendResponse(socket, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
          socket.end();
          return;
        }
      } else {
        sendResponse(socket, 416, { 'Content-Type': 'text/plain' }, '416 Range Not Satisfiable');
        socket.end();
        return;
      }
    }

    const len = end - start + 1;
    const stream = createReadStream(abs, { start, end });
    const headers = {
      'Content-Type': getMimeType(filename) ?? 'application/octet-stream',
      'Accept-Ranges': 'bytes',
      'Content-Range': `bytes ${start}-${end}/${size}`,
      'Content-Length': String(len),
    };

    sendResponse(socket, 206, headers, stream);

    stream.on('error', () => socket.end());
  }
  /* ------------------------------------------------------------------ */
}
</file>

<file path="package.json">
{
  "name": "my-central-hub",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "nodemon src/main.ts",
    "format": "prettier --write \"src/**/*.{ts,js,json,md}\" \"tests/**/*.{ts,js,json,md}\"",
    "format:check": "prettier --check \"src/**/*.{ts,js,json,md}\" \"tests/**/*.{ts,js,json,md}\"",
    "clean": "rm -rf dist",
    "build": "npm run clean && tsc",
    "start": "node dist/main.js",
    "test": "jest",
    "type-check": "tsc --noEmit",
    "lint:ts": "eslint src tests --ext .ts",
    "lint:md": "markdownlint --fix './**/*.md' --ignore node_modules --ignore dist --ignore coverage --ignore public",
    "lint": "npm-run-all lint:ts lint:md"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/toluLikesToCode/my-central-hub.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/toluLikesToCode/my-central-hub/issues"
  },
  "homepage": "https://github.com/toluLikesToCode/my-central-hub#readme",
  "devDependencies": {
    "@eslint/js": "^9.25.1",
    "@types/jest": "^29.5.14",
    "@typescript-eslint/eslint-plugin": "^8.31.0",
    "@typescript-eslint/parser": "^8.31.0",
    "eslint": "^9.25.1",
    "eslint-config-prettier": "^10.1.2",
    "eslint-plugin-markdown": "^5.1.0",
    "eslint-plugin-prettier": "^5.2.6",
    "husky": "^9.1.7",
    "jest": "^29.7.0",
    "markdownlint-cli": "^0.44.0",
    "nodemon": "^3.1.10",
    "npm-run-all": "^4.1.5",
    "prettier": "^3.5.3",
    "ts-jest": "^29.3.2",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.31.0"
  },
  "dependencies": {
    "dotenv": "^16.5.0"
  }
}
</file>

</files>
